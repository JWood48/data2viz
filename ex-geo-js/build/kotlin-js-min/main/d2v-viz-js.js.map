{"version":3,"file":"d2v-viz-js.js","sources":["util/Preconditions.kt","collections/Collections.kt","kotlin/math.kt","../../../../../d2v-viz-common/src/main/kotlin/io/data2viz/viz/CircleNode.kt","../../../../../d2v-viz-common/src/main/kotlin/io/data2viz/viz/DslExtensions.kt","../../../../../d2v-viz-common/src/main/kotlin/io/data2viz/viz/Events.kt","generated/_Collections.kt","../../../../../d2v-viz-common/src/main/kotlin/io/data2viz/viz/GroupNode.kt","util/Standard.kt","../../../../../d2v-viz-common/src/main/kotlin/io/data2viz/viz/Layer.kt","../../../../../d2v-viz-common/src/main/kotlin/io/data2viz/viz/LineNode.kt","../../../../../d2v-viz-common/src/main/kotlin/io/data2viz/viz/Node.kt","../../../../../d2v-viz-common/src/main/kotlin/io/data2viz/viz/PathNode.kt","../../../../../d2v-viz-common/src/main/kotlin/io/data2viz/viz/RectNode.kt","../../../../../d2v-viz-common/src/main/kotlin/io/data2viz/viz/StateManager.kt","../../../../../d2v-viz-common/src/main/kotlin/io/data2viz/viz/Style.kt","../../../../../d2v-viz-common/src/main/kotlin/io/data2viz/viz/TextNode.kt","../../../../../d2v-viz-common/src/main/kotlin/io/data2viz/viz/Viz.kt","../../../../../d2v-viz-common/src/main/kotlin/io/data2viz/viz/VizConfig.kt","../../../../src/main/kotlin/io/data2viz/viz/JsCanvasRenderer.kt","collections/MutableCollections.kt","../../../../src/main/kotlin/io/data2viz/viz/JsCircleRenderer.kt","../../../../src/main/kotlin/io/data2viz/viz/JsColorOrGradientRenderer.kt","../../../../src/main/kotlin/io/data2viz/viz/JsEvents.kt","../../../../src/main/kotlin/io/data2viz/viz/JsGroupRenderer.kt","../../../../src/main/kotlin/io/data2viz/viz/JsLineRenderer.kt","../../../../src/main/kotlin/io/data2viz/viz/JsPathRenderer.kt","../../../../src/main/kotlin/io/data2viz/viz/JsRectRenderer.kt","../../../../src/main/kotlin/io/data2viz/viz/JsTextRenderer.kt","org.w3c/org.w3c.dom.kt"],"sourcesContent":["/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which [comparison] function returns zero using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the provided [comparison],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that compares an element of the list with the element being searched.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n@file:Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.Math as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x).unsafeCast<Double>() // TODO: Remove unsafe cast after removing public js.math\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x).unsafeCast<Double>()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x).unsafeCast<Double>()\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.withSign(sign: Double): Double {\n    val thisSignBit = js(\"Kotlin\").doubleSignBit(this).unsafeCast<Int>()\n    val newSignBit = js(\"Kotlin\").doubleSignBit(sign).unsafeCast<Int>()\n    return if (thisSignBit == newSignBit) this else -this\n}\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n",null,null,"package io.data2viz.viz\n\nimport io.data2viz.geom.Point\nimport kotlin.math.pow\nimport kotlin.math.sqrt\n\n\nfun <T> VizRenderer.addEventHandle(handle: KEventHandle<T>) where T : io.data2viz.viz.KEvent {\n\n    if (handle.isAddedToRenderer) {\n        error(\"Can't add event handle which already added to Renderer\")\n    }\n\n    handle.disposable = addNativeEventListenerFromHandle(handle)\n}\n\nexpect fun <T> VizRenderer.addNativeEventListenerFromHandle(handle: KEventHandle<T>): Disposable where T : KEvent\n\nfun <T> VizRenderer.removeEventHandle(handle: KEventHandle<T>) where T : io.data2viz.viz.KEvent {\n\n    if (!handle.isAddedToRenderer) {\n        error(\"Can't remove event handle which not added to Renderer. $handle\")\n    }\n\n    handle.disposable!!.dispose()\n    handle.disposable = null\n}\n\n/**\n * TODO: Make generic disposable class in API?\n */\ninterface Disposable {\n    fun dispose()\n}\n\nclass CompositeDisposable(val disposables: MutableList<Disposable> = mutableListOf()) : Disposable {\n    override fun dispose() {\n        disposables.forEach { it.dispose() }\n        disposables.clear()\n    }\n\n    fun add(disposable: Disposable) {\n        disposables.add(disposable)\n    }\n\n}\n\n/**\n * Marker interface on events.\n */\ninterface KEvent\n\n\nclass KEventHandle<T>(\n    val eventListener: KEventListener<T>,\n    val listener: (T) -> Unit,\n    val onDispose: (KEventHandle<T>) -> Unit\n) : Disposable where T : KEvent {\n\n    var disposable: Disposable? = null\n\n    val isAddedToRenderer get() = disposable != null\n\n    override fun dispose() {\n        onDispose(this)\n    }\n\n    override fun toString(): String {\n        return \"KEventHandle(eventListener=$eventListener)\"\n    }\n}\n\n/**\n * Common Pointer event. Can be subclassed into more specific events.\n * Gives access to the position of the event.\n */\nopen class KPointerEvent(\n    val pos: Point\n) : KEvent {\n    override fun toString(): String = \"KPointerEvent(pos=$pos)\"\n}\n\n/**\n * Pointer events for platform with Mouse input device.\n * Somebody may want use KMouseEvent by casting KPointerEvent to more specific type\n * Used in JFX & JS implementations. Android implementation use common KPointerEvent\n */\nclass KMouseEvent(\n    pos: Point,\n    val altKey: Boolean,\n    val ctrlKey: Boolean,\n    val shiftKey: Boolean,\n    val metaKey: Boolean\n) : KPointerEvent(pos) {\n    override fun toString(): String = \"KMouseEvent(pos=$pos)\"\n}\n\nclass KDragEvent(\n    val action: KDragAction,\n    val pointerEvent: KPointerEvent\n) : KEvent {\n    val pos get() = pointerEvent.pos\n    override fun toString(): String = \"KDragEvent(action=$action, pos=$pos)\"\n\n    enum class KDragAction {\n        Start, Dragging, Finish\n    }\n}\n\n@Experimental\n@Retention(AnnotationRetention.BINARY)\n@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION)\nannotation class ExperimentalKZoomEvent            // Experimental API marker\n\n\n@ExperimentalKZoomEvent\nclass KZoomEvent(\n    val startZoomPos: Point,\n    val currentZoomPos: Point,\n    val delta: Double\n) : KEvent {\n    companion object {\n\n        const val diffTimeBetweenZoomEventsToDetectRestart = 500\n        fun isNewZoom(currentTime: Double, lastTime: Double?) =\n            if (lastTime == null) {\n                true\n            } else {\n                currentTime - lastTime > diffTimeBetweenZoomEventsToDetectRestart\n            }\n\n        fun isNewZoom(currentTime: Long, lastTime: Long?) =\n            if (lastTime == null) {\n                true\n            } else {\n                currentTime - lastTime > diffTimeBetweenZoomEventsToDetectRestart\n            }\n\n        const val minDelta = -100.0\n        const val maxDelta = 100.0\n\n        fun scaleDelta(\n            currentDelta: Double,\n            originMinDelta: Double,\n            originMaxDelta: Double,\n            newMinDelta: Double = minDelta,\n            newMaxDelta: Double = maxDelta\n        ): Double {\n            val originBoundsSize = originMaxDelta - originMinDelta\n            val currentDeltaPercentInBounds = (currentDelta - originMinDelta) / originBoundsSize\n\n            val newBoundsSize = newMaxDelta - newMinDelta\n            var newDeltaValue = newMinDelta + newBoundsSize * currentDeltaPercentInBounds\n\n            if (newDeltaValue > maxDelta) {\n                newDeltaValue = maxDelta\n            }\n\n            if (newDeltaValue < minDelta) {\n                newDeltaValue = minDelta\n\n            }\n\n            return newDeltaValue\n        }\n    }\n\n    override fun toString(): String {\n        return \"KZoomEvent(startZoomPos=$startZoomPos, delta=$delta)\"\n    }\n\n}\n\n\ninterface KEventListener<T> where  T : KEvent {\n    fun addNativeListener(target: Any, listener: (T) -> Unit): Disposable\n}\n\nexpect class KPointerMove {\n    companion object PointerMoveEventListener : KEventListener<KPointerEvent>\n}\n\nexpect class KPointerDown {\n    companion object PointerDownEventListener : KEventListener<KPointerEvent>\n}\n\nexpect class KPointerUp {\n    companion object PointerUpEventListener : KEventListener<KPointerEvent>\n}\n\nexpect class KPointerEnter {\n    companion object PointerEnterEventListener : KEventListener<KPointerEvent>\n}\n\nexpect class KPointerLeave {\n    companion object PointerLeaveEventListener : KEventListener<KPointerEvent>\n}\n\nexpect class KPointerClick {\n    companion object PointerClickEventListener : KEventListener<KPointerEvent>\n}\n\nexpect class KPointerDoubleClick {\n    companion object PointerDoubleClickEventListener : KEventListener<KPointerEvent>\n}\n\n@ExperimentalKZoomEvent\nexpect class KZoom {\n    companion object ZoomEventListener : KEventListener<KZoomEvent>\n}\n\nclass KPointerDrag {\n    companion object PointerDragEventListener : KEventListener<KDragEvent> {\n\n\n        private var downActionPos: Point? = null\n        private var dragInProgress: Boolean = false\n\n        override fun addNativeListener(target: Any, listener: (KDragEvent) -> Unit): Disposable {\n\n            val compositeDisposable = CompositeDisposable()\n\n            compositeDisposable.add(KPointerMove.addNativeListener(target) {\n                if (dragInProgress) {\n                    listener(KDragEvent(KDragEvent.KDragAction.Dragging, it))\n                } else {\n\n                    val startPos = downActionPos\n                    if (startPos != null) {\n                        dragInProgress = true\n                        listener(KDragEvent(KDragEvent.KDragAction.Start, it))\n                    }\n                }\n            })\n\n            compositeDisposable.add(KPointerLeave.addNativeListener(target) {\n                onDragNotPossible(listener, it)\n            })\n\n            compositeDisposable.add(KPointerDown.addNativeListener(target) {\n                downActionPos = it.pos\n\n            })\n\n            compositeDisposable.add(KPointerUp.addNativeListener(target) {\n                onDragNotPossible(listener, it)\n            })\n\n            return compositeDisposable\n        }\n\n        /**\n         * TODO: Move to API?\n         */\n        private fun distance(pos1: Point, pos2: Point): Double {\n            val xSquare = (pos1.x - pos2.x).pow(2.0)\n            val ySquare = (pos1.y - pos2.y).pow(2.0)\n            return sqrt(xSquare + ySquare)\n        }\n\n        private fun onDragNotPossible(listener: (KDragEvent) -> Unit, motionEvent: KPointerEvent) {\n            downActionPos = null\n            if (dragInProgress) {\n                dragInProgress = false\n                listener(KDragEvent(KDragEvent.KDragAction.Finish, motionEvent))\n            }\n\n        }\n    }\n}\n\n\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count++ >= n) list.add(item)\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original collection.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    var maxValue = selector(maxElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    var minValue = selector(minElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<List<T>>((thisSize + step - 1) / step)\n        var index = 0\n        while (index < thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<R>((thisSize + step - 1) / step)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index < thisSize) {\n            window.move(index, (index + size).coerceAtMost(thisSize))\n            if (!partialWindows && window.size < size) break\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"package io.data2viz.viz\n\n\nimport io.data2viz.geom.Point\nimport org.w3c.dom.HTMLElement\nimport org.w3c.dom.events.Event\nimport org.w3c.dom.events.EventListener\nimport org.w3c.dom.events.MouseEvent\nimport org.w3c.dom.events.WheelEvent\nimport kotlin.js.Date\n\n\nactual class KPointerDown {\n    actual companion object PointerDownEventListener : KEventListener<KPointerEvent> {\n        override fun addNativeListener(target: Any, listener: (KPointerEvent) -> Unit): Disposable =\n            createJsListener(target, listener, \"mousedown\")\n    }\n}\n\nactual class KPointerUp {\n    actual companion object PointerUpEventListener : KEventListener<KPointerEvent> {\n        override fun addNativeListener(target: Any, listener: (KPointerEvent) -> Unit): Disposable =\n            createJsListener(target, listener, \"mouseup\")\n    }\n}\n\nactual class KPointerEnter {\n    actual companion object PointerEnterEventListener : KEventListener<KPointerEvent> {\n        override fun addNativeListener(target: Any, listener: (KPointerEvent) -> Unit): Disposable =\n            createJsListener(target, listener, \"mouseenter\")\n    }\n}\n\nactual class KPointerLeave {\n    actual companion object PointerLeaveEventListener : KEventListener<KPointerEvent> {\n        override fun addNativeListener(target: Any, listener: (KPointerEvent) -> Unit): Disposable =\n            createJsListener(target, listener, \"mouseleave\")\n    }\n}\n\n\nactual class KPointerDoubleClick {\n    actual companion object PointerDoubleClickEventListener : KEventListener<KPointerEvent> {\n        override fun addNativeListener(target: Any, listener: (KPointerEvent) -> Unit): Disposable =\n            createJsListener(target, listener, \"dblclick\")\n    }\n}\n\nactual class KPointerMove {\n    actual companion object PointerMoveEventListener : KEventListener<KPointerEvent> {\n        override fun addNativeListener(target: Any, listener: (KPointerEvent) -> Unit): Disposable =\n            createJsListener(target, listener, \"mousemove\")\n    }\n}\n\nactual class KPointerClick {\n    actual companion object PointerClickEventListener : KEventListener<KPointerEvent> {\n        override fun addNativeListener(target: Any, listener: (KPointerEvent) -> Unit): Disposable =\n            createJsListener(target, listener, \"click\")\n    }\n}\n\n@ExperimentalKZoomEvent\nactual class KZoom {\n    actual companion object ZoomEventListener : KEventListener<KZoomEvent> {\n\n        const val minGestureZoomDeltaValue = -10.0\n        const val maxGestureZoomDeltaValue = 10.0\n\n        const val minWheelZoomDeltaValue = -100.0\n        const val maxWheelZoomDeltaValue = 100.0\n\n        var lastZoomTime: Double? = null\n        lateinit var zoomStartPoint: Point\n\n        override fun addNativeListener(target: Any, listener: (KZoomEvent) -> Unit): Disposable {\n            val htmlElement = target.unsafeCast<HTMLElement>()\n            val nativeListener = object : EventListener {\n                override fun handleEvent(event: Event) {\n                    (event as WheelEvent).apply {\n                        // don't actually zoom/scroll in browser\n                        event.preventDefault()\n                        // invert value to work as Android & JFX\n                        val invertedDelta = deltaY * -1\n\n                        val currentTime = Date.now()\n                        val zoomPoint = Point(\n                            clientX.toDouble() - htmlElement.offsetLeft,\n                            clientY.toDouble() - htmlElement.offsetTop\n                        )\n                        if (KZoomEvent.isNewZoom(currentTime, lastZoomTime)) {\n                            zoomStartPoint = zoomPoint\n                        }\n                        if (event.ctrlKey) {\n                            // wheel\n                            listener(\n                                KZoomEvent(\n                                    zoomStartPoint,\n                                    zoomPoint,\n                                    KZoomEvent.scaleDelta(invertedDelta, minWheelZoomDeltaValue, maxWheelZoomDeltaValue)\n                                )\n                            )\n                        } else {\n                            // gesture\n                            listener(\n                                KZoomEvent(\n                                    zoomStartPoint,\n                                    zoomPoint,\n                                    KZoomEvent.scaleDelta(\n                                        invertedDelta,\n                                        minGestureZoomDeltaValue,\n                                        maxGestureZoomDeltaValue\n                                    )\n                                )\n                            )\n                        }\n                        lastZoomTime = currentTime\n                    }\n                }\n            }\n            return JsListener(htmlElement, \"wheel\", nativeListener).also { it.init() }\n        }\n    }\n}\n\n\nprivate fun createJsListener(\n    target: Any,\n    listener: (KPointerEvent) -> Unit,\n    jsEventName: String\n): JsListener {\n    val htmlElement = target.unsafeCast<HTMLElement>()\n    val nativeListener = object : EventListener {\n        override fun handleEvent(event: Event) {\n            val nativeEvent = event.convertToKEvent(htmlElement)\n            listener(nativeEvent)\n        }\n    }\n\n    return JsListener(htmlElement, jsEventName, nativeListener).also { it.init() }\n}\n\ndata class JsListener(val htmlElement: HTMLElement, val type: String, val listener: EventListener) :\n    Disposable {\n    fun init() {\n        htmlElement.addEventListener(type, listener)\n    }\n\n    override fun dispose() {\n        htmlElement.removeEventListener(type, listener)\n    }\n\n}\n\n\nactual fun <T> VizRenderer.addNativeEventListenerFromHandle(handle: KEventHandle<T>): Disposable where T : KEvent {\n    val jsCanvasRenderer = this as JsCanvasRenderer\n    return handle.eventListener.addNativeListener(jsCanvasRenderer.context.canvas, handle.listener)\n}\n\n\nfun Event.convertToKEvent(target: HTMLElement): KPointerEvent = unsafeCast<MouseEvent>().run {\n    val kPointerMoveEvent =\n        KMouseEvent(\n            Point(clientX.toDouble() - target.offsetLeft, clientY.toDouble() - target.offsetTop),\n            this.altKey,\n            this.ctrlKey,\n            this.shiftKey,\n            this.metaKey\n        )\n    kPointerMoveEvent\n}\n",null,null,null,null,null,null],"names":[],"mappings":"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AAc,I;IACd,aAAS,cAAO,IAAP,C;EACb,C;;IAGI,aAAS,Q;EACb,C;;IAGS,gBADmD,e;IAC7C,IC4Cf,W;ID3CgB,iBC4CT,SD5CS,C;IAF4C,OC8CrD,S;ED9CqD,C;;IAKnD,gBADgD,c;IAC1C,ICwCf,W;IDvCgB,iBCwCT,SDxCS,C;IAFyC,OC0ClD,S;ED1CkD,C;;IAKhD,gBADsD,gB;IAChD,ICoCf,W;IDnCgB,iBCoCT,SDpCS,C;IAF+C,OCsCxD,S;EDtCwD,C;;IAKtD,gBADgD,c;IAC1C,ICgCf,W;ID/BgB,iBCgCT,SDhCS,C;IAFyC,OCkClD,S;EDlCkD,C;;IAKhD,gBADgD,c;IAC1C,IC4Bf,W;ID3BgB,iBC4BT,SD5BS,C;IAFyC,OC8BlD,S;ED9BkD,C;;IAKhD,gBADgD,c;IAC1C,ICwBf,W;IDvBgB,iBCwBT,SDxBS,C;IAFyC,OC0BlD,S;ED1BkD,C;;;;;;;;;;;;;;IE3ChD,oB;EAHb,C;;;;;;;ICDiB,e;IAIb,2BAAqC,I;IAErC,UAAiB,G;IACjB,UAAiB,G;IACjB,UAAiB,G;IACjB,UAAiB,G;EATrB,C;;;MAII,+B;IAAA,C;;MAAA,oC;IAAA,C;;;;;;;;ICKA,wBAA2B,I;IAU3B,eAKuB,I;IASvB,uBAAuC,sBAAkB,WAAlB,C;EA9B3C,C;;;MAOgB,4B;IAAA,C;;MAEJ,wBAAQ,K;MACR,8BAAe,K;IACnB,C;;;IAgBA,Q;IAAA,oDAAe,IAAf,e;EACJ,C;;;MAKY,OAAA,oBAAM,K;IAAN,C;;MACI,4BAAa,K;IAAK,C;;;;MAEtB,OAAA,oBAAM,O;IAAN,C;;MACI,8BAAe,K;IAAK,C;;;;MAExB,OAAA,oBAAM,Y;IAAN,C;;MACI,mCAAoB,K;IAAK,C;;;;MAE7B,OAAA,oBAAM,U;IAAN,C;;MACI,iCAAkB,K;IAAK,C;;;;MAE3B,OAAA,oBAAM,O;IAAN,C;;MACI,8BAAe,K;IAAK,C;;;;MAIxB,kB;IAAA,C;;MACI,cAAS,K;IAAK,C;;;;MAElB,OAAA,oBAAM,O;IAAN,C;;MAEJ,8BAAe,K;IAAK,C;;;;MAIhB,kB;IAAA,C;;MAEJ,cAAS,K;IAAK,C;;;;;;;;IC7DN,oB;MAAA,OAAqB,c;IAAa,e;IAAlC,gB;IAMhB,2BAAqC,I;EANtB,C;;;MAMf,+B;IAAA,C;;MAAA,oC;IAAA,C;;;IAOI,SAAK,Y;EACT,C;;IAVI,sG;EAAA,C;;IAAA,sD;EAAA,C;;IAAA,oE;EAAA,C;;IAAA,4B;EAAA,C;;IAAA,qC;EAAA,C;;IAAA,qC;EAAA,C;;IAAA,yD;EAAA,C;;IAAA,yC;EAAA,C;;;;;;;ICJO,oB;MAAA,OAAa,c;IAAc,e;IAClC,2BAAQ,I;EADF,C;;;MACN,sC;IAAA,C;;;;MAAA,0C;IAAA,C;;;;MAAA,2C;IAAA,C;;;;MAAA,sC;IAAA,C;;;;MAAA,sC;IAAA,C;;MAAA,sC;IAAA,C;;;;MAAA,oC;IAAA,C;;;;MAAA,qC;IAAA,C;;;;MAAA,oC;IAAA,C;;MAAA,oC;IAAA,C;;;;MAAA,mC;IAAA,C;;;;MAAA,uC;IAAA,C;;;;MAAA,wC;IAAA,C;;;;MAAA,qC;IAAA,C;;MAAA,qC;IAAA,C;;;;MAAA,iC;IAAA,C;;MAAA,iC;IAAA,C;;;;MAAA,iC;IAAA,C;;MAAA,iC;IAAA,C;;;IAAA,uD;EAAA,C;;IAAA,sD;EAAA,C;;;;;;;ICEJ,mD;IAEA,kBb+EoD,gB;EatFxD,C;;IAUQ,eAAW,WAAI,QAAJ,C;EACf,C;;IAGI,gE;IR4hDY,Q;IAAA,OQ3hDZ,eR2hDY,W;IAAhB,OAAgB,cAAhB,C;MAAgB,yB;MAAa,OQ1hDlB,4B;;IAEP,mD;EACJ,C;;;;;;;IAEJ,e;IAAA,iB;IAAA,uB;EAAA,C;;IAAA,4C;IAAA,C;IACI,oE;IAAM,wE;IAAQ,8F;EADlB,C;;;IACI,+B;IAAA,uC;EAAA,C;;;IAAM,+B;IAAA,yC;EAAA,C;;;IAAQ,+B;IAAA,oD;EAAA,C;;;;;;;IADlB,2I;EAAA,C;;;IAAA,a;MAAA,Y;QAAA,4C;MAAA,c;QAAA,8C;MAAA,yB;QAAA,yD;MAAA,QAAA,uE;;EAAA,C;;;;;;;;;;;;;;;;;ICGI,sBAAsC,I;IACtC,wBAAwC,I;IACxC,2BAA2C,I;IAC3C,6BAAoC,G;IACpC,qD;IACA,wBAAkC,W;IACl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,EAAE,YAAG,0BAAH,kDAAkB,GAApB,CAAnC,C;UACA,eAAO,EAAE,YAAG,uBAAH,sDAAmB,GAArB,CAAP,C;;;;IAMX,OAAQ,WAAU,GAAV,EAAc,GAAd,C;EACT,C;;ICzCI,OAAQ,Y;IACR,OAAQ,QAAO,YAAP,EAAW,YAAX,C;IACR,OAAQ,QAAO,YAAP,EAAW,YAAX,C;IACR,OAAQ,S;EACZ,C;;ICaI,UAMA,M;IAtBA,OAAQ,Y;IpBuiDQ,U;IAAA,SoBtiDhB,cAAK,SpBsiDW,W;IAAhB,OAAgB,gBAAhB,C;MAAgB,2B;MoBpiDR,kBpBoiDqB,OoBpiDrB,U;QAAqB,epBoiDA,OoBpiDW,EAAX,EpBoiDA,OoBpiDkB,EAAlB,C;WACrB,kBpBmiDqB,OoBniDrB,U;QAAqB,epBmiDA,OoBniDW,EAAX,EpBmiDA,OoBniDkB,EAAlB,C;WACrB,kBpBkiDqB,OoBliDrB,oB;QAA+B,yBpBkiDV,OoBliD+B,IAArB,EpBkiDV,OoBliDwC,IAA9B,EpBkiDV,OoBliDiD,EAAvC,EpBkiDV,OoBliDwD,EAA9C,C;WAC/B,kBpBiiDqB,OoBjiDrB,iB;QAA4B,sBpBiiDP,OoBjiDyB,KAAlB,EpBiiDP,OoBjiDmC,KAA5B,EpBiiDP,OoBjiD6C,KAAtC,EpBiiDP,OoBjiDuD,KAAhD,EpBiiDP,OoBjiDiE,EAA1D,EpBiiDP,OoBjiDwE,EAAjE,C;WAC5B,kBpBgiDqB,OoBhiDrB,O;QAAkB,YpBgiDG,OoBhiDK,QAAR,EpBgiDG,OoBhiDkB,QAArB,EpBgiDG,OoBhiD+B,OAAlC,EpBgiDG,OoBhiD2C,WAA9C,EpBgiDG,OoBhiD2D,SAA9D,EpBgiDG,OoBhiDyE,iBAA5E,C;WAClB,kBpB+hDqB,OoB/hDrB,S;QAAoB,cpB+hDC,OoB/hDS,MAAV,EpB+hDC,OoB/hDoB,MAArB,EpB+hDC,OoB/hD+B,EAAhC,EpB+hDC,OoB/hDsC,EAAvC,EpB+hDC,OoB/hD6C,OAA9C,C;WACpB,kBpB8hDqB,OoB9hDrB,a;QAAwB,mB;WACxB,kBpB6hDqB,OoB7hDrB,W;QAAsB,apB6hDD,OoB7hDU,EAAT,EpB6hDD,OoB7hDiB,EAAhB,EpB6hDD,OoB7hDwB,EAAvB,EpB6hDD,OoB7hD+B,EAA9B,C;;Q1B8He,MAAM,2BAA8B,C0B7H3D,4DpB4hDO,OoB5hDP,C1B6H2D,YAA9B,C;;;I0BxHnD,oC;MACI,oBAAuB,4B;MACf,c;;IAIZ,wC;MAEwB,U;MADpB,sBAAyB,8B;MACzB,oBAAoB,oDAAe,G;MAC3B,gB;;EAIhB,C;;IC7BC,UAKA,M;IALA,oC;MACC,oBAAuB,4B;MACf,iBAAS,WAAT,EAAY,WAAZ,EAAe,eAAf,EAAsB,gBAAtB,C;;IAGT,wC;MACC,sBAAyB,8B;MACjB,mBAAW,WAAX,EAAc,WAAd,EAAiB,eAAjB,EAAwB,gBAAxB,C;;EAGV,C;;QCNC,I;IALA,oBAA2B,SAAP,gBAAO,C;IAC3B,uBAA8B,OAAP,gBAAO,C;IAE9B,eAA4B,SAAV,mBAAU,CAAb,SAA8B,SAAX,oBAAW,CAA9B,SAAoC,kBAApC,WAAkD,oBAAW,K;IAE5E,yC;MACC,oBAAuB,4B;MACf,iBAAS,qBAAT,EAAsB,WAAtB,EAAyB,WAAzB,C;;IAGT,6B;MACS,mBAAW,qBAAX,EAAwB,WAAxB,EAA2B,WAA3B,C;;EAEV,C;;IAGS,QAAK,SAAL,M;WACP,U;QADO,OC2rI0F,Y;WDzrIjG,S;QAFO,OCyrIoF,S;WDtrI3F,Q;QAHO,OC0rIkF,Q;cD1rIlF,mC;;EAAA,C;;IAOA,QAAK,SAAL,M;WACP,O;WAAA,M;QADO,OCyqIwE,M;WDvqI/E,K;WAAA,O;QAFO,OC0qI0E,O;WDvqIjF,Q;QAHO,OC2qI4E,Q;cD3qI5E,mC;;EAAA,C;;IAOA,QAAK,SAAL,M;WACP,Q;QADO,OACc,Q;WACrB,M;QAFO,OAEc,M;cAFd,mC;;EAAA,C;;IAMA,QAAK,SAAL,M;WACP,Q;QADO,OACgB,Q;WACvB,Q;QAFO,OAEe,Q;cAFf,mC;;EAAA,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}
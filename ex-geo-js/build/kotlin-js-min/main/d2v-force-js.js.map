{"version":3,"file":"d2v-force-js.js","sources":["collections/Collections.kt","kotlin/math.kt","generated/_Collections.kt","runtime/arrayUtils.kt","collections/Maps.kt","../../../../../d2v-force-common/src/main/kotlin/io/data2viz/force/Force.kt","util/Standard.kt","../../../../../d2v-force-common/src/main/kotlin/io/data2viz/force/ForceCenter.kt","../../../../../d2v-force-common/src/main/kotlin/io/data2viz/force/ForceCollision.kt","../../../../../../../../../../dummy.kt","../../../../../d2v-force-common/src/main/kotlin/io/data2viz/force/ForceLink.kt","../../../../../d2v-force-common/src/main/kotlin/io/data2viz/force/ForceNBody.kt","../../../../../d2v-force-common/src/main/kotlin/io/data2viz/force/ForceNode.kt","../../../../../d2v-force-common/src/main/kotlin/io/data2viz/force/ForcePoint.kt","../../../../../d2v-force-common/src/main/kotlin/io/data2viz/force/ForceRadial.kt","../../../../../d2v-force-common/src/main/kotlin/io/data2viz/force/ForceSimulation.kt","../../../../../d2v-force-common/src/main/kotlin/io/data2viz/force/ForceX.kt","../../../../../d2v-force-common/src/main/kotlin/io/data2viz/force/ForceY.kt"],"sourcesContent":["/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which [comparison] function returns zero using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the provided [comparison],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that compares an element of the list with the element being searched.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n@file:Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.Math as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x).unsafeCast<Double>() // TODO: Remove unsafe cast after removing public js.math\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x).unsafeCast<Double>()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x).unsafeCast<Double>()\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.withSign(sign: Double): Double {\n    val thisSignBit = js(\"Kotlin\").doubleSignBit(this).unsafeCast<Int>()\n    val newSignBit = js(\"Kotlin\").doubleSignBit(sign).unsafeCast<Int>()\n    return if (thisSignBit == newSignBit) this else -this\n}\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count++ >= n) list.add(item)\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original collection.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    var maxValue = selector(maxElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    var minValue = selector(minElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<List<T>>((thisSize + step - 1) / step)\n        var index = 0\n        while (index < thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<R>((thisSize + step - 1) / step)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index < thisSize) {\n            window.move(index, (index + size).coerceAtMost(thisSize))\n            if (!partialWindows && window.size < size) break\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n@PublishedApi\nexternal internal fun <T> Array(size: Int): Array<T>\n\n@JsName(\"newArray\")\nfun <T> newArray(size: Int, initValue: T) = fillArrayVal(Array<T>(size), initValue)\n\n@JsName(\"newArrayF\")\ninline fun <T> arrayWithFun(size: Int, init: (Int) -> T) = fillArrayFun(Array<T>(size), init)\n\n@JsName(\"fillArray\")\ninline fun <T> fillArrayFun(array: Array<T>, init: (Int) -> T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = init(i)\n    }\n    return array\n}\n\n@JsName(\"booleanArray\")\nfun booleanArray(size: Int, init: dynamic): Array<Boolean> {\n    val result: dynamic = Array<Boolean>(size)\n    result.`$type$` = \"BooleanArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, false)\n        false -> result\n        else -> fillArrayFun<Boolean>(result, init)\n    }\n}\n\n@JsName(\"booleanArrayF\")\ninline fun booleanArrayWithFun(size: Int, init: (Int) -> Boolean): Array<Boolean> = fillArrayFun(booleanArray(size, false), init)\n\n@JsName(\"charArray\")\n@Suppress(\"UNUSED_PARAMETER\")\nfun charArray(size: Int, init: dynamic): Array<Char> {\n    val result = js(\"new Uint16Array(size)\")\n    result.`$type$` = \"CharArray\"\n    return when (init) {\n        null, true, false -> result // For consistency\n        else -> fillArrayFun<Char>(result, init)\n    }\n}\n\n@JsName(\"charArrayF\")\ninline fun charArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = charArray(size, null)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"untypedCharArrayF\")\ninline fun untypedCharArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = Array<Char>(size)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"longArray\")\nfun longArray(size: Int, init: dynamic): Array<Long> {\n    val result: dynamic = Array<Long>(size)\n    result.`$type$` = \"LongArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, 0L)\n        false -> result\n        else -> fillArrayFun<Long>(result, init)\n    }\n}\n\n@JsName(\"longArrayF\")\ninline fun longArrayWithFun(size: Int, init: (Int) -> Long): Array<Long> = fillArrayFun(longArray(size, false), init)\n\nprivate fun <T> fillArrayVal(array: Array<T>, initValue: T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = initValue\n    }\n    return array\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Calculate the initial capacity of a map, based on Guava's com.google.common.collect.Maps approach. This is equivalent\n * to the Collection constructor for HashSet, (c.size()/.75f) + 1, but provides further optimisations for very small or\n * very large sizes, allows support non-collection classes, and provides consistency for all map based class construction.\n */\n@PublishedApi\ninternal fun mapCapacity(expectedSize: Int): Int {\n    if (expectedSize < 3) {\n        return expectedSize + 1\n    }\n    if (expectedSize < INT_MAX_POWER_OF_TWO) {\n        return expectedSize + expectedSize / 3\n    }\n    return Int.MAX_VALUE // any large value\n}\n\nprivate const val INT_MAX_POWER_OF_TWO: Int = Int.MAX_VALUE / 2 + 1\n\n/** Returns `true` if this map is not empty. */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable map is either null or empty.\n * @sample samples.collections.Maps.Usage.mapIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || isEmpty()\n}\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n *\n * @sample samples.collections.Maps.Usage.mapOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Returns this map if it's not empty\n * or the result of calling [defaultValue] function if the map is empty.\n *\n * @sample samples.collections.Maps.Usage.mapIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <M, R> M.ifEmpty(defaultValue: () -> R): R where M : Map<*, *>, M : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n *\n * @sample samples.collections.Maps.Usage.containsValue\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","package io.data2viz.force\n\nimport io.data2viz.math.EPSILON\nimport kotlin.random.Random\n\nfun <D> forceSimulation(init: ForceSimulation<D>.() -> Unit) = ForceSimulation<D>().apply { init() }\n\ninternal fun jiggle() = (Random.nextDouble() - 0.5) * EPSILON\n\ninterface Force<D> {\n\n    /**\n     * Assigns nodes to this force.\n     * This method is called when a force is bound to a simulation via simulation.force and when the simulation\u2019s\n     * nodes change via simulation.nodes.\n     * A force may perform necessary work during initialization, such as evaluating per-node parameters, to avoid\n     * repeatedly performing work during each application of the force.\n     *\n     * Todo should be internal. No use outside of package\n     */\n    fun assignNodes(nodes: List<ForceNode<D>>)\n\n    /**\n     * Applies this force, optionally observing the specified intensity.\n     * Typically, the force is applied to the array of nodes previously passed to force.assignNodes, however, some\n     * forces may apply to a subset of nodes, or behave differently.\n     * For example, forceLink applies to the source and target of each link.\n     */\n    fun applyForceToNodes(intensity: Double)\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","package io.data2viz.force\n\nimport io.data2viz.geom.Point\n\n@Deprecated(\"Deprecated\", ReplaceWith(\"forceSimulation { forceCenter { } }\", \" io.data2viz.force.ForceSimulation\"))\nfun <D> forceCenter(center: Point) = ForceCenter<D>().apply { this.center = center }\n\n/**\n * The centering force translates nodes uniformly so that the mean position of all nodes\n * (the center of mass if all nodes have equal weight) is at the given position \u27e8x,y\u27e9.\n * This force modifies the positions of nodes on each application; it does not modify velocities,\n * as doing so would typically cause the nodes to overshoot and oscillate around the desired center.\n * This force helps keeps nodes in the center of the viewport, and unlike the positioning force,\n * it does not distort their relative positions.\n */\nclass ForceCenter<D> internal constructor() : Force<D> {\n\n    private var _nodes = listOf<ForceNode<D>>()\n\n    var center: Point = Point(.0, .0)\n\n    override fun assignNodes(nodes: List<ForceNode<D>>) {\n        _nodes = nodes\n    }\n\n    override fun applyForceToNodes(intensity: Double) {\n        val size = _nodes.size.toDouble()\n\n        var sx = .0\n        var sy = .0\n\n        _nodes.forEach { node ->\n            sx += node.x\n            sy += node.y\n        }\n\n        sx = sx / size - center.x\n        sy = sy / size - center.y\n\n        _nodes.forEach { node ->\n            node.x = node.x - sx\n            node.y = node.y - sy\n        }\n    }\n}","package io.data2viz.force\n\nimport io.data2viz.math.pct\nimport io.data2viz.quadtree.*\nimport kotlin.math.*\n\n@Deprecated(\"Deprecated\", ReplaceWith(\"forceSimulation { forceCollision { } }\", \" io.data2viz.force.ForceSimulation\"))\nfun <D> forceCollision(init: ForceCollision<D>.() -> Unit) = ForceCollision<D>().apply(init)\n\n/**\n * The collision force treats _nodes as circles with a given radius, rather than points, and prevents _nodes from\n * overlapping. More formally, two _nodes a and b are separated so that the distance between a and b is at least\n * radius(a) + radius(b).\n * To reduce jitter, this is by default a \u201csoft\u201d constraint with a configurable strength and iteration count.\n */\nclass ForceCollision<D> internal constructor(): Force<D> {\n\n    private val x = { node: ForceNode<D> -> node.x }\n    private val y = { node: ForceNode<D> -> node.y }\n\n    // variables stored during tree parsing for current node\n    private var ri: Double = .0\n    private var ri2: Double = .0\n    private var xi: Double = Double.NaN\n    private var yi: Double = Double.NaN\n    private lateinit var currentNode: ForceNode<D>\n\n    /**\n     * If iterations is specified, sets the number of iterations per application to the specified number, defaults 1.\n     * Increasing the number of iterations greatly increases the rigidity of the constraint and avoids partial overlap\n     * of _nodes, but also increases the runtime cost to evaluate the force.\n     */\n    var iterations = 1\n        set(value) {\n            field = max(1, value)\n        }\n\n    /**\n     * Sets the force strength to the specified percentage coerced in the range [0%,100%].\n     * Value defaults to 70%.\n     * Overlapping _nodes are resolved through iterative relaxation. For each node, the other _nodes that are anticipated\n     * to overlap at the next tick (using the anticipated positions \u27e8x + vx,y + vy\u27e9) are determined; the node\u2019s velocity\n     * is then modified to push the node out of each overlapping node. The change in velocity is dampened by the force\u2019s\n     * strength such that the resolution of simultaneous overlaps can be blended together to find a stable solution.\n     */\n    var strength = 70.pct\n        set(value) {\n            field = value.coerceToDefault()\n        }\n\n    /**\n     * Sets the radius accessor to the specified function, re-evaluates the radius accessor which defaults to { 100.0 }\n     * for each node.\n     *\n     * The radius accessor is invoked for each node in the simulation, being passed the node, its zero-based index\n     * and the list of _nodes.\n     * The resulting number is then stored internally, such that the radius of each node is only recomputed when the\n     * force is initialized or when this method is called with a new radius, and not on every application of the force.\n     */\n    var radiusGet: ForceNode<D>.() -> Double = { 100.0 }\n        set(value) {\n            field = value\n            assignNodes(_nodes)\n        }\n\n    private var _nodes: List<ForceNode<D>> = listOf()\n    private var _radiuses = listOf<Double>()\n\n    override fun assignNodes(nodes: List<ForceNode<D>>) {\n        _nodes = nodes\n        _radiuses = nodes.map(radiusGet)\n    }\n\n    override fun applyForceToNodes(intensity: Double) {\n        (0 until iterations).forEach {\n            val tree = quadtree(x, y, _nodes)\n            tree.visitAfter(::prepare)\n            _nodes.forEachIndexed { index, node ->\n                currentNode = node\n                ri = _radiuses[node.index]\n                ri2 = ri * ri\n                xi = node.x + node.vx\n                yi = node.y + node.vy\n                tree.visit(::applyForce)\n            }\n        }\n    }\n\n    private fun applyForce(quad: QuadtreeNode<ForceNode<D>>, x0: Double, y0: Double, x1: Double, y1: Double): Boolean {\n        val data = if (quad is LeafNode) quad.data else null\n        var rj = quad.value!!\n        var r = ri + rj\n        if (data != null) {\n            if (data.index > currentNode.index) {\n                var x = xi - data.x - data.vx\n                var y = yi - data.y - data.vy\n                var l = x * x + y * y\n                if (l < (r * r)) {\n                    if (x == .0) {\n                        x = jiggle()\n                        l += x * x\n                    }\n                    if (y == .0) {\n                        y = jiggle()\n                        l += y * y\n                    }\n                    val sqrtl = sqrt(l)\n                    l = (r - (sqrtl)) / sqrtl * strength.value\n                    x *= l\n                    y *= l\n                    rj *= rj\n                    r = rj / (ri2 + rj)\n                    currentNode.vx += x * r\n                    currentNode.vy += y * r\n                    r = 1 - r\n                    data.vx -= x * r\n                    data.vy -= y * r\n                }\n            }\n            return false\n        }\n        return x0 > xi + r || x1 < xi - r || y0 >yi + r || y1 < yi - r\n    }\n\n    private fun prepare(quad: QuadtreeNode<ForceNode<D>>, x0: Double, y0: Double, x1: Double, y1: Double) {\n        if (quad is LeafNode) {\n            quad.value = _radiuses[quad.data.index]\n            return\n        }\n        quad.value = .0\n        (quad as InternalNode).toList().forEach { node ->\n            if (node?.value != null && node.value!! > quad.value!!) {\n                quad.value = node.value\n            }\n        }\n    }\n}",null,"package io.data2viz.force\n\nimport kotlin.math.*\n\n// TODO Link rename to something more precise ?\n/**\n * A Link object records a link a source and a target ForceNode.\n * The force will try to keep the 2 nodes at the specified distance, with the specified strength.\n * Default distance is 30.0.\n * Default strength is NaN. If strength is left at NaN, a strength of 1/X will be applied where X is the minimum\n * number of links between the 2 nodes. This default was chosen because it automatically reduces the strength of links\n * connected to heavily-connected nodes, improving stability.\n */\ndata class Link<D>(\n    val source: ForceNode<D>,\n    val target: ForceNode<D>,\n    val distance: Double = 30.0,\n    var strength: Double = Double.NaN\n)\n\n@Deprecated(\"Deprecated\", ReplaceWith(\"forceSimulation { forceLink { } }\", \" io.data2viz.force.ForceSimulation\"))\nfun <D> forceLink(init: ForceLink<D>.() -> Unit) = ForceLink<D>().apply(init)\n\n/**\n * The link force pushes linked nodes together or apart according to the desired link distance.\n * The strength of the force is proportional to the difference between the linked nodes\u2019 distance and the target\n * distance, similar to a spring force.\n */\nclass ForceLink<D> internal constructor(): Force<D> {\n\n    private var _nodes = listOf<ForceNode<D>>()\n\n    private var _links = listOf<Link<D>>()\n    val links: List<Link<D>>\n        get() = _links\n\n    private var bias: Array<Double> =  arrayOf()\n    private var count:Array<Int> = arrayOf()\n\n    /**\n     * Number of iterations per application.\n     * Increasing the number of iterations greatly increases the rigidity of the constraint and avoids partial overlap\n     * of nodes, but also increases the runtime cost to evaluate the force.\n     */\n    var iterations = 1\n\n    /**\n     * Get the list of links from a given ForceNode, defaults to null.\n     * Each Link must have a reference to a source node, a target node, a distance value (defaults to 30.0) and\n     * a strength (defaults to Double.NaN) value.\n     */\n    var linkGet: ForceNode<D>.()-> List<Link<D>>? = { null }\n\n    override fun assignNodes(nodes: List<ForceNode<D>>) {\n        _nodes = nodes\n        _links = nodes.mapNotNull(linkGet).flatten()\n\n        // count links for each nodes\n        count = Array(nodes.size){ 0 }\n        _links.forEachIndexed { index, link ->\n            count[link.source.index] += 1\n            count[link.target.index] += 1\n        }\n\n        // count bias\n        bias = Array(_links.size) {.0}\n        _links.forEachIndexed { index, link ->\n            bias[index] = count[link.source.index].toDouble() / (count[link.source.index] + count[link.target.index])\n        }\n\n        initializeStrengths()\n    }\n\n    /**\n     * When a link strength is not set (default value is Double.NaN) it automatically compute it strength.\n     * Strength computed is 1 / the number of links with the given node as a source or target.\n     * This default was chosen because it automatically reduces the strength of links connected to\n     * heavily-connected nodes, improving stability.\n     */\n    private fun initializeStrengths() {\n        _links.filter { it.strength.isNaN() }\n            .forEach { it.strength = 1.0 / min(count[it.source.index], count[it.target.index]) }\n    }\n\n    override fun applyForceToNodes(intensity: Double) {\n        (0 until iterations).forEach {\n            _links.forEachIndexed { index, link ->\n                val source = link.source\n                val target = link.target\n\n                var x = target.x + target.vx - source.x - source.vx\n                if (x == .0) x = jiggle()\n\n                var y = target.y + target.vy - source.y - source.vy\n                if (y == .0) y = jiggle()\n\n                var l = sqrt(x * x + y * y)\n                l = (l - link.distance) / l * intensity * link.strength\n                x *= l\n                y *= l\n\n                var b = bias[index]\n                target.vx -= x * b\n                target.vy -= y * b\n\n                b = 1 - b\n                source.vx += x * b\n                source.vy += y * b\n            }\n        }\n    }\n}","package io.data2viz.force\n\nimport io.data2viz.quadtree.*\nimport kotlin.math.*\n\n/**\n * The n-body force applies mutually amongst all nodes.\n * It can be used to simulate gravity (attraction) if the strength is positive, or electrostatic charge (repulsion)\n * if the strength is negative.\n * This implementation uses quadtrees and the Barnes\u2013Hut approximation to greatly improve performance;\n * the accuracy can be customized using the theta parameter.\n *\n * Unlike links, which only affect two linked nodes, the charge force is global: every node affects every other node,\n * even if they are on disconnected subgraphs.\n */\n\n@Deprecated(\"Deprecated\", ReplaceWith(\"forceSimulation { forceNBody { } }\", \" io.data2viz.force.ForceSimulation\"))\nfun <D> forceNBody(init: ForceNBody<D>.() -> Unit) = ForceNBody<D>().apply(init)\n\nclass ForceNBody<D> internal constructor(): Force<D> {\n\n    private var theta2 = .81\n    private var distanceMin2 = 1.0\n    private var distanceMax2 = 10000.0\n\n    private val x = { node: ForceNode<D> -> node.x }\n    private val y = { node: ForceNode<D> -> node.y }\n\n    // store the intensity value for the current force(intensity) call\n    private var currentIntensity: Double = .0\n\n    // store the current node we're applying force\n    private lateinit var currentNode: ForceNode<D>\n\n    /**\n     * Reuse the Barnes\u2013Hut approximation to speed up the force calculations, defaults to a recalculation every 7\n     * ticks of the force simulation.\n     * Use lower values for more precision (but higher runtime), and higher values to speed-up your force.\n     *\n     * Based on this research paper: https://osf.io/wgzn5/\n     */\n    // TODO reactivate this when performance will be measured\n    /*var optimisation = 7\n        set(value) {\n            field = value.coerceAtLeast(1)\n            iteration = 0\n        }*/\n\n\n    /**\n     * Sets the Barnes\u2013Hut approximation criterion to the specified number which defaults to 0.9.\n     *\n     * To accelerate computation, this force implements the Barnes\u2013Hut approximation which takes O(n log n) per\n     * application where n is the number of nodes.\n     * For each application, a quadtree stores the current node positions; then for each node, the combined force of\n     * all other nodes on the given node is computed. For a cluster of nodes that is far away, the charge force can be\n     * approximated by treating the cluster as a single, larger node. The theta parameter determines the accuracy of the\n     * approximation: if the ratio w / l of the width w of the quadtree cell to the distance l from the node to the\n     * cell\u2019s center of mass is less than theta, all nodes in the given cell are treated as a single node rather\n     * than individually.\n     */\n    var theta: Double\n        get() = sqrt(theta2)\n        set(value) {\n            theta2 = value * value\n        }\n\n    /**\n     * Sets the minimum distance between nodes (which defaults to 1) over which this force is considered.\n     * A minimum distance establishes an upper bound on the strength of the force between two nearby nodes, avoiding\n     * instability. In particular, it avoids an infinitely-strong force if two nodes are exactly coincident; in this\n     * case, the direction of the force is random.\n     * Defaults to 1.0\n     */\n    var distanceMin: Double\n        get() = sqrt(distanceMin2)\n        set(value) {\n            distanceMin2 = value * value\n        }\n\n    /**\n     * Sets the maximum distance between nodes (which defaults to infinity) over which this force is considered.\n     * Specifying a finite maximum distance improves performance and produces a more localized layout.\n     * Defaults to 100.0\n     */\n    var distanceMax: Double\n        get() = sqrt(distanceMax2)\n        set(value) {\n            distanceMax2 = value * value\n        }\n\n    /**\n     * Sets the strength accessor to the specified function, re-evaluates the strength accessor for each node.\n     * A positive value causes nodes to attract each other, similar to gravity, while a negative value causes nodes to\n     * repel each other, similar to electrostatic charge.\n     *\n     * If strength is not specified, returns the current strength accessor, which defaults to { -30.0 }.\n     *\n     * The strength accessor is invoked for each node in the simulation, being passed the node and its zero-based index.\n     * The resulting number is then stored internally, such that the strength of each node is only recomputed when the\n     * force is initialized or when this method is called with a new strength, and not on every application of the force.\n     */\n    var strengthGet: ForceNode<D>.() -> Double = { -30.0 }\n        set(value) {\n            field = value\n            assignNodes(_nodes)\n        }\n\n    private var _nodes: List<ForceNode<D>> = listOf()\n    private var _strengths = listOf<Double>()\n\n    override fun assignNodes(nodes: List<ForceNode<D>>) {\n        _nodes = nodes\n        _strengths = nodes.map(strengthGet)\n    }\n\n    override fun applyForceToNodes(intensity: Double) {\n        currentIntensity = intensity\n\n        val tree = quadtree(x, y, _nodes)\n        tree.visitAfter(::accumulate)\n        _nodes.forEachIndexed { index, node ->\n            currentNode = node\n            tree.visit(::applyForce)\n        }\n    }\n\n    private fun applyForce(quad: QuadtreeNode<ForceNode<D>>, x0: Double, y0: Double, x1: Double, y1: Double): Boolean {\n        if (quad.value == null) return true\n\n        var x: Double = quad.x - currentNode.x\n        var y: Double = quad.y - currentNode.y\n        var w = x1 - x0\n        var l = x * x + y * y\n\n        // Apply the Barnes-Hut approximation if possible.\n        // Limit forces for very close nodes; randomize direction if coincident.\n        if (w * w / theta2 < l) {\n            if (l < distanceMax2) {\n                if (x == .0) {\n                    x = jiggle()\n                    l += x * x\n                }\n                if (y == .0) {\n                    y = jiggle()\n                    l += y * y\n                }\n                if (l < distanceMin2) l = sqrt(distanceMin2 * l)\n                val increment: Double = quad.value!! * currentIntensity / l\n                currentNode.vx += x * increment\n                currentNode.vy += y * increment\n            }\n\n            return true\n        }\n\n        // Otherwise, process points directly.\n        else if (quad is InternalNode || l >= distanceMax2) return false\n\n        // Limit forces for very close nodes; randomize direction if coincident.\n        var newQuad = quad as LeafNode?\n        if (newQuad!!.data !== currentNode || newQuad!!.next == null) {\n            if (x == .0) {\n                x = jiggle()\n                l += x * x\n            }\n            if (y == .0) {\n                y = jiggle()\n                l += y * y\n            }\n            if (l < distanceMin2) l = sqrt(distanceMin2 * l)\n        }\n\n        do {\n            if (newQuad!!.data !== currentNode) {\n                w = _strengths[newQuad!!.data.index] * currentIntensity / l\n                currentNode.vx += x * w\n                currentNode.vy += y * w\n            }\n            newQuad = newQuad!!.next\n        } while (newQuad != null)\n\n        return false\n    }\n\n    private fun accumulate(quad: QuadtreeNode<ForceNode<D>>, x0: Double, y0: Double, x1: Double, y1: Double) {\n        var strength = .0\n        var weight = .0\n\n        // For internal nodes, accumulate forces from child quadrants.\n        when (quad) {\n            is InternalNode -> {\n                var x = .0\n                var y = .0\n                quad.toList().forEach { q ->\n                    if (q?.value != null) {\n                        val c = abs(q.value!!)\n                        strength += q.value!!\n                        weight += c\n                        x += c * q.x\n                        y += c * q.y\n                    }\n                }\n                quad.x = x / weight\n                quad.y = y / weight\n            }\n\n            // For leaf nodes, accumulate forces from coincident quadrants.\n            is LeafNode -> {\n                var q: LeafNode<ForceNode<D>>? = quad\n                q!!.x = q.data.x\n                q.y =  q.data.y\n                do {\n                    strength += _strengths[q!!.data.index]\n                    q = q.next\n                } while (q != null)\n            }\n        }\n\n        quad.value = strength\n    }\n}","package io.data2viz.force\n\nimport io.data2viz.geom.Point\nimport io.data2viz.geom.Vector\nimport io.data2viz.geom.point\n\n\n/**\n * The position \u27e8x,y\u27e9 and velocity \u27e8vx,vy\u27e9 may be subsequently modified by forces and by the simulation.\n * If either vx or vy is NaN, the velocity is initialized to \u27e80,0\u27e9. If either x or y is NaN, the position\n * is initialized in a phyllotaxis arrangement, so chosen to ensure a deterministic, uniform distribution around the origin.\n *\n * To fix a node in a given position, you may specify two additional properties:\n *      fx - the node\u2019s fixed x-position\n *      fy - the node\u2019s fixed y-position\n *\n * At the end of each tick, after the application of any forces, a node with a defined node.fx\n * has node.x reset to this value and node.vx set to zero; likewise, a node with a defined node.fy\n * has node.y reset to this value and node.vy set to zero. To unfix a node that was previously fixed,\n * set node.fx and node.fy to null, or delete these properties.\n *\n * If the specified array of nodes is modified, such as when nodes are added to or removed from the\n * simulation, this method must be called again with the new (or changed) array to notify the simulation and bound\n * forces of the change; the simulation does not make a defensive copy of the specified array.\n */\n\ndata class ForceNode<D> (\n    val index: Int,\n    val domain: D,\n    var x: Double = Double.NaN,\n    var y: Double = Double.NaN,\n    var vx: Double = Double.NaN,\n    var vy: Double = Double.NaN,\n    var fixedX: Double? = null,\n    var fixedY: Double? = null\n) {\n    var position:Point\n        get() = point(x, y)\n        set(value) {\n            x = value.x\n            y = value.y\n        }\n\n    var velocity:Vector\n        get() = Vector(vx, vy)\n        set(value) {\n            vx = value.vx\n            vy = value.vy\n        }\n}","package io.data2viz.force\n\nimport io.data2viz.geom.*\nimport io.data2viz.math.*\n\n/**\n * Creates a new positioning force towards the given position .\n * If point is not specified, it defaults to (0, 0).\n */\nclass ForcePoint<D> internal constructor(): Force<D> {\n\n    private val defaultPoint = point(0, 0)\n\n    /**\n     * Sets the coordinate accessor to the specified function, re-evaluates the accessor for each node.\n     * If pointGet is not specified, returns the current accessor, which defaults to { point(0, 0) }\n     * The accessor is invoked for each node in the simulation, being passed the node and its zero-based index.\n     * The resulting number is then stored internally, such that the target coordinate of each node is only recomputed\n     * when the force is initialized or when this method is called with a new point, and not on every\n     * application of the force.\n     */\n    var pointGet: ForceNode<D>.() -> Point = { defaultPoint }\n        set(value) {\n            field = value\n            assignNodes(_nodes)\n        }\n\n    /**\n     * Sets the strength accessor to the specified function, re-evaluates the strength accessor for each node.\n     * The strength determines how much to increment the node\u2019s velocity: (point - node.position) \u00d7 strength.\n     * For example, a value of 10% indicates that the node should move a tenth of the way from its current position\n     * to the target position with each application. Higher values moves nodes more quickly to the target position,\n     * often at the expense of other forces or constraints. A value outside the range [0,100] is not recommended.\n     *\n     * If strength is not specified, returns the current strength accessor, which defaults to { 10% }.\n     *\n     * The strength accessor is invoked for each node in the simulation, being passed the node and its zero-based index.\n     * The resulting number is then stored internally, such that the strength of each node is only recomputed when the\n     * force is initialized or when this method is called with a new strength, and not on every application of the force.\n     */\n    var strengthGet: ForceNode<D>.() -> Percent = { 10.pct }\n        set(value) {\n            field = value\n            assignNodes(_nodes)\n        }\n\n    private var _nodes: List<ForceNode<D>> = listOf()\n    private var _strengths = listOf<Double>()\n    private var _x = listOf<Double>()\n    private var _y = listOf<Double>()\n\n    override fun assignNodes(nodes: List<ForceNode<D>>) {\n        _nodes = nodes\n\n        _x = nodes.map { it.pointGet().x }\n        _y = nodes.map { it.pointGet().y }\n        _strengths = nodes.map { it.strengthGet().value }\n    }\n\n    override fun applyForceToNodes(intensity: Double) {\n        _nodes.forEachIndexed { index, node ->\n            node.vx += (_x[index] - node.x) * _strengths[index] * intensity\n            node.vy += (_y[index] - node.y) * _strengths[index] * intensity\n        }\n    }\n}","package io.data2viz.force\n\nimport io.data2viz.geom.*\nimport io.data2viz.math.*\nimport kotlin.math.sqrt\n\n@Deprecated(\"Deprecated\", ReplaceWith(\"forceSimulation { forceRadial { } }\", \" io.data2viz.force.ForceSimulation\"))\nfun <D> forceRadial(init: ForceRadial<D>.() -> Unit) = ForceRadial<D>().apply(init)\n\n/**\n * Creates a new positioning force towards a circle of the specified radius centered at \"center\" Point.\n */\nclass ForceRadial<D> internal constructor(): Force<D> {\n\n    /**\n     * Sets the circle radius to the specified function, re-evaluates the radius accessor for each node.\n     * The radius accessor is invoked for each node in the simulation, being passed the node and its zero-based index.\n     * The resulting number is then stored internally, such that the radius of each node is only recomputed when the\n     * force is initialized or when this method is called with a new radius, and not on every application of the force.\n     */\n    var radiusGet: ForceNode<D>.() -> Double = { 100.0 }\n        set(value) {\n            field = value\n            assignNodes(_nodes)\n        }\n\n    /**\n     * Sets the strength accessor to the specified function, re-evaluates the strength accessor for each node.\n     * The strength determines how much to increment the node\u2019s x- and y-velocity.\n     * For example, the default value of 10% indicates that the node should move a tenth of the way from its current\n     * position to the closest point on the circle with each application.\n     * Higher values moves nodes more quickly to the target position, often at the expense of other forces or constraints.\n     * A value outside the range [0,100] is not recommended.\n     *\n     * The strength accessor is invoked for each node in the simulation, being passed the node and its zero-based index.\n     * The resulting number is then stored internally, such that the strength of each node is only recomputed when the\n     * force is initialized or when this method is called with a new strength, and not on every application of the force.\n     */\n    var strengthGet: ForceNode<D>.() -> Percent = { 10.pct }\n        set(value) {\n            field = value\n            assignNodes(_nodes)\n        }\n\n    /**\n     * Sets the coordinate of the circle center which defaults to (0, 0).\n     */\n    var centerGet: ForceNode<D>.() -> Point = { defaultCenter }\n        set(value) {\n            field = value\n            assignNodes(_nodes)\n        }\n    private val defaultCenter = Point(.0, .0)\n\n    private var _nodes: List<ForceNode<D>> = listOf()\n    private var _strengths = listOf<Double>()\n    private var _centers = listOf<Point>()\n    private var _radiuses = listOf<Double>()\n\n    override fun assignNodes(nodes: List<ForceNode<D>>) {\n        _nodes = nodes\n\n        _radiuses = nodes.map(radiusGet)\n        _strengths = nodes.map { it.strengthGet().value }\n        _centers = nodes.map(centerGet)\n    }\n\n    override fun applyForceToNodes(intensity: Double) {\n        _nodes.forEachIndexed { index, node ->\n            var dx = node.x - _centers[index].x\n            if (dx == .0) dx = EPSILON\n            var dy = node.y - _centers[index].y\n            if (dy == .0) dy = EPSILON\n\n            val r = sqrt(dx * dx + dy * dy)\n            val k = (_radiuses[index] - r) * _strengths[index] * intensity / r\n\n            node.vx += dx * k\n            node.vy += dy * k\n        }\n    }\n}","package io.data2viz.force\n\nimport io.data2viz.geom.Point\nimport io.data2viz.math.Percent\nimport io.data2viz.math.pct\nimport io.data2viz.timer.timer\nimport kotlin.math.*\n\nprivate const val initialRadius = 10.0\nprivate val initialAngle = PI * (3.0 - sqrt(5.0))\n\n/**\n * Creates a new simulation with the specified array of nodes and no forces.\n * If nodes is not specified, it defaults to the empty list.\n * The simulator starts automatically; use simulation.on to listen for tick events as the simulation runs.\n * If you wish to run the simulation manually instead, call simulation.stop, and then call simulation.tick as desired.\n */\nclass ForceSimulation<D> internal constructor() {\n\n    private var started = false\n\n    // AVAILABLE FORCES\n    fun forceX(init: ForceX<D>.() -> Unit = {}) = addForce(ForceX<D>().apply(init)) as ForceX\n    fun forceY(init: ForceY<D>.() -> Unit = {}) = addForce(ForceY<D>().apply(init)) as ForceY\n    fun forcePoint(init: ForcePoint<D>.() -> Unit = {}) = addForce(ForcePoint<D>().apply(init)) as ForcePoint\n    fun forceRadial(init: ForceRadial<D>.() -> Unit) = addForce(ForceRadial<D>().apply(init)) as ForceRadial\n    fun forceNBody(init: ForceNBody<D>.() -> Unit = {}) = addForce(ForceNBody<D>().apply(init)) as ForceNBody\n    fun forceCollision(init: ForceCollision<D>.() -> Unit) = addForce(ForceCollision<D>().apply(init)) as ForceCollision\n    fun forceCenter(init: ForceCenter<D>.() -> Unit) = addForce(ForceCenter<D>().apply(init)) as ForceCenter\n    fun forceLink(init: ForceLink<D>.() -> Unit = {}) = addForce(ForceLink<D>().apply(init)) as ForceLink\n\n    /**\n     * The initForceNode lambda applies to each ForceNode.\n     * A ForceNode is created for each domain objects passed to the simulation.\n     * ForceNode already have an index, and a domain object, so you can use these 2 properties to initialize your nodes.\n     */\n    var initForceNode: ForceNode<D>.() -> Unit = { }\n        set(value) {\n            field = value\n            initSimulation(true)\n        }\n\n    /**\n     * Pass your domain objects to the simulation and initialize the ForceNodes.\n     * If there are no existing nodes, or the domain object associated to a node at a given index have changed,\n     * then the node is initialized using the initForceNode lambda.\n     * If at a given index, the \"new\" domain object is the same as the \"old\" one, the node will keep its\n     * properties.\n     * This allows you to add some nodes \"on the fly\" in the simulation just by setting the domainObjects var.\n     * Just be careful, your domain objects must keep the same index, so new objects must be added at the end\n     * of the list.\n     */\n    var domainObjects: List<D> = listOf()\n        set(value) {\n            field = value\n            initSimulation(true)\n        }\n\n    private var _nodes = listOf<ForceNode<D>>()\n    val nodes: List<ForceNode<D>>\n        get() = _nodes\n\n    private var _forces = listOf<Force<D>>()\n    val forces: List<Force<D>>\n        get() = _forces\n\n\n    private val tickEvents = mutableMapOf<String, (ForceSimulation<D>) -> Unit>()\n    private val endEvents = mutableMapOf<String, (ForceSimulation<D>) -> Unit>()\n    private val stepper = timer { step() }\n\n    /**\n     * Restarts current simulation\n     */\n    fun play() {\n        stepper.restart { step() }\n    }\n\n    /**\n     * stops the current simulation\n     */\n    fun stop() {\n        stepper.stop()\n    }\n\n    private fun step() {\n        tick()\n        tickEvents.values.forEach { callback ->\n            callback(this)\n        }\n        if (intensity < intensityMin) {\n            stepper.stop()\n            endEvents.values.forEach { callback ->\n                callback(this)\n            }\n        }\n    }\n\n\n    /**\n     * Sets the current intensity to the specified positive percentage in the range which defaults to 100%.\n     */\n    var intensity = 100.pct\n        set(value) {\n            field = value.coerceAtLeast(0.pct)\n        }\n\n    /**\n     * Sets the minimum intensity to the specified positive percentage (defaults to 0.1%).\n     * The simulation\u2019s internal timer stops when the current intensity is less than the minimum intensity.\n     * The default intensity decay rate of ~2.28% corresponds to 300 iterations.\n     */\n    var intensityMin = 0.1.pct\n        set(value) {\n            field = value.coerceAtLeast(0.pct)\n        }\n\n    /**\n     * Sets the intensity decay rate to the specified positive percentage.\n     * Defaults to 2.28\u2026% = 1 - pow(0.1%, 1 / 300) where 0.1% is the default minimum intensity.\n     *\n     * The intensity decay rate determines how quickly the current intensity interpolates towards the desired target\n     * intensity; since the default target intensity is zero, by default this controls how quickly the simulation cools.\n     * Higher decay rates cause the simulation to stabilize more quickly, but risk getting stuck in a local minimum;\n     * lower values cause the simulation to take longer to run, but typically converge on a better layout.\n     *\n     * To have the simulation run forever at the current intensity, set the decay rate to zero; alternatively, set a\n     * target intensity greater than the minimum intensity.\n     */\n    var intensityDecay = Percent(1.0 - intensityMin.value.pow(1.0 / 300.0))\n        set(value) {\n            field = value.coerceAtLeast(0.pct)\n        }\n\n    /**\n     * Sets the current target intensity to the specified positive percentage (defaults to 0%).\n     */\n    var intensityTarget = 0.pct\n        set(value) {\n            field = value.coerceAtLeast(0.pct)\n        }\n\n    private var _friction = 0.6\n\n    /**\n     * Sets the friction factor to the specified percentage in the range [0,100] which defaults to 40%.\n     * As with lowering the intensity decay rate, less friction may converge on a better solution, but risks\n     * numerical instabilities and oscillation.\n     */\n    var friction\n        get() = Percent(1 - _friction)\n        set(value) {\n            _friction = 1 - value.coerceToDefault().value\n        }\n\n    /**\n     * Add the force in this simulation.\n     */\n    private fun addForce(force: Force<D>):Force<D> {\n        initializeForce(force)\n        _forces += force\n        return force\n    }\n\n    /**\n     * InitSimulation is called when the simulation starts.\n     * Check if everything is initialized as some properties may have been set after some others.\n     * updateNodes is set to false when the simulation starts (this erase all nodes values) else it is set to true\n     * (this update all previous nodes values)\n     */\n    private fun initSimulation(updateNodes:Boolean) {\n        initializeNodes(updateNodes)\n        _forces.forEach { initializeForce(it) }\n    }\n\n    /**\n     * Removes the force in this simulation.\n     */\n    fun removeForce(force: Force<D>) {\n        _forces -= force\n    }\n\n    private fun initializeForce(force: Force<D>) {\n        force.assignNodes(nodes)\n    }\n\n    /**\n     * Increments the current intensity by (intensityTarget - intensity) \u00d7 intensityDecay;\n     * then invokes each registered force, passing the new intensity;\n     * then decrements each node\u2019s velocity by velocity \u00d7 friction;\n     * lastly increments each node\u2019s position by velocity.\n     *\n     * This method does not dispatch events;\n     * events are only dispatched by the internal timer when the simulation is started automatically upon creation\n     * or by calling simulation.restart.\n     * The natural number of ticks when the simulation is started is \u2308log(intensityMin) / log(1 - intensityDecay)\u2309;\n     * by default, this is 300.\n     *\n     * This method can be used in conjunction with simulation.stop to compute a static force layout.\n     */\n    // TODO For large graphs, static layouts should be computed in a web worker to avoid freezing the user interface.\n    // TODO private ?\n    fun tick() {\n        if (!started) {\n            started = true\n            initSimulation(false)\n        }\n\n        intensity += (intensityTarget - intensity) * intensityDecay\n\n        _forces.forEach { force ->\n            force.applyForceToNodes(intensity.value)\n        }\n\n        nodes.forEach { node ->\n            if (node.fixedX != null) {\n                node.x = node.fixedX!!\n                node.vx = .0\n            } else {\n                node.vx *= _friction\n                node.x += node.vx\n            }\n            if (node.fixedY != null) {\n                node.y = node.fixedY!!\n                node.vy = .0\n            } else {\n                node.vy *= _friction\n                node.y += node.vy\n            }\n        }\n    }\n\n    private fun initializeNodes(updateNodes:Boolean) {\n        val oldNodes = _nodes.toList()\n        val oldNodeSize = oldNodes.size\n        _nodes = List(domainObjects.size) { ForceNode(it, domainObjects[it]) }\n        domainObjects.forEachIndexed { index, domain ->\n            val node = _nodes[index]\n            if (updateNodes && index < oldNodeSize && oldNodes[index].domain == node.domain) {\n                val oldNode = oldNodes[index]\n                node.position = oldNode.position\n                node.velocity = oldNode.velocity\n                node.fixedX = oldNode.fixedX\n                node.fixedY = oldNode.fixedY\n            } else {\n                node.initForceNode()\n                if (node.x.isNaN() || node.y.isNaN()) {\n                    val radius = initialRadius * sqrt(index.toDouble())\n                    val angle = index * initialAngle\n                    node.x = radius * cos(angle)\n                    node.y = radius * sin(angle)\n                }\n                if (node.vx.isNaN() || node.vy.isNaN()) {\n                    node.vx = .0\n                    node.vy = .0\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns the node closest to the position with the given search radius.\n     * If radius is not specified, it defaults to infinity.\n     * If there is no node within the search area, returns null.\n     */\n    fun find(point: Point, radius: Double = Double.POSITIVE_INFINITY): ForceNode<D>? {\n        var newRadius = if (radius < Double.POSITIVE_INFINITY) radius * radius else radius\n        var closest: ForceNode<D>? = null\n\n        nodes.forEach { node ->\n            val dx = point.x - node.x\n            val dy = point.y - node.y\n            val d2 = dx * dx + dy * dy\n            if (d2 < newRadius) {\n                closest = node\n                newRadius = d2\n            }\n        }\n\n        return closest\n    }\n\n    /**\n     * If listener is specified, sets the event listener for the specified typenames and returns this simulation.\n     * If an event listener was already registered for the same type and name, the existing listener is removed\n     * before the new listener is added.\n     * If listener is null, removes the current event listeners for the specified typenames, if any.\n     * If listener is not specified, returns the first currently-assigned listener matching the specified typenames, if any.\n     * When a specified event is dispatched, each listener will be invoked with the this context as the simulation.\n     *\n     * The typenames is a string containing one or more typename separated by whitespace.\n     * Each typename is a type, optionally followed by a period (.) and a name, such as tick.foo and tick.bar;\n     * the name allows multiple listeners to be registered for the same type. The type must be one of the following:\n     *\n     * - tick - after each tick of the simulation\u2019s internal timer.\n     * - end - after the simulation\u2019s timer stops when intensity < intensityMin.\n     *\n     * Note that tick events are not dispatched when simulation.tick is called manually;\n     * events are only dispatched by the internal timer and are intended for interactive rendering of the simulation.\n     *\n     * To affect the simulation, register forces instead of modifying nodes\u2019 positions or velocities inside a tick\n     * event listener.\n     */\n    // TODO : change doc and plug to dispatch (?)\n    fun on(type: SimulationEvent, name: String, callback: (ForceSimulation<D>) -> Unit) {\n        when (type) {\n            SimulationEvent.TICK -> tickEvents[name] = callback\n            SimulationEvent.END -> endEvents[name] = callback\n        }\n    }\n\n}\n\nenum class SimulationEvent {\n    TICK, END\n}\n\n","package io.data2viz.force\n\nimport io.data2viz.math.*\n\n@Deprecated(\"Deprecated\", ReplaceWith(\"forceSimulation { forceX { } }\", \" io.data2viz.force.ForceSimulation\"))\nfun <D> forceX(init: ForceX<D>.() -> Unit) = ForceX<D>().apply(init)\n\n/**\n * Creates a new positioning force along the x-axis towards the given position x.\n * If x is not specified, it defaults to 0.\n */\nclass ForceX<D> internal constructor(): Force<D> {\n\n    /**\n     * Sets the x-coordinate accessor to the specified function, re-evaluates the x-accessor for each node.\n     * If x is not specified, returns the current x-accessor, which defaults to { .0 }\n     * The x-accessor is invoked for each node in the simulation, being passed the node and its zero-based index.\n     * The resulting number is then stored internally, such that the target x-coordinate of each node is only recomputed\n     * when the force is initialized or when this method is called with a new x, and not on every application of the force.\n     */\n    var xGet: ForceNode<D>.() -> Double = { .0 }\n        set(value) {\n            field = value\n            assignNodes(_nodes)\n        }\n\n    /**\n     * Sets the strength accessor to the specified function, re-evaluates the strength accessor for each node.\n     * The strength determines how much to increment the node\u2019s x-velocity: (x - node.x) \u00d7 strength.\n     * For example, a value of 10% indicates that the node should move a tenth of the way from its current x-position\n     * to the target x-position with each application. Higher values moves nodes more quickly to the target position,\n     * often at the expense of other forces or constraints. A value outside the range [0,100] is not recommended.\n     *\n     * If strength is not specified, returns the current strength accessor, which defaults to { 10% }.\n     *\n     * The strength accessor is invoked for each node in the simulation, being passed the node and its zero-based index.\n     * The resulting number is then stored internally, such that the strength of each node is only recomputed when the\n     * force is initialized or when this method is called with a new strength, and not on every application of the force.\n     */\n    var strengthGet: ForceNode<D>.() -> Percent = { 10.pct }\n        set(value) {\n            field = value\n            assignNodes(_nodes)\n        }\n\n    private var _nodes = listOf<ForceNode<D>>()\n    private var _strengths = listOf<Double>()\n    private var _x = listOf<Double>()\n\n    override fun assignNodes(nodes: List<ForceNode<D>>) {\n        _nodes = nodes\n\n        _x = nodes.map(xGet)\n        _strengths = nodes.map { it.strengthGet().value }\n    }\n\n    override fun applyForceToNodes(intensity: Double) {\n        _nodes.forEachIndexed { index, node ->\n            node.vx += (_x[index] - node.x) * _strengths[index] * intensity\n        }\n    }\n}","package io.data2viz.force\n\nimport io.data2viz.math.*\n\n@Deprecated(\"Deprecated\", ReplaceWith(\"forceSimulation { forceY { } }\", \" io.data2viz.force.ForceSimulation\"))\nfun <D> forceY(init: ForceY<D>.() -> Unit) = ForceY<D>().apply(init)\n\n/**\n * Creates a new positioning force along the y-axis towards the given position y.\n * If y is not specified, it defaults to 0.\n */\nclass ForceY<D> internal constructor(): Force<D> {\n\n    /**\n     * Sets the y-coordinate accessor to the specified function, re-evaluates the y-accessor for each node.\n     * If y is not specified, returns the current y-accessor, which defaults to { .0 }\n     * The y-accessor is invoked for each node in the simulation, being passed the node and its zero-based index.\n     * The resulting number is then stored internally, such that the target y-coordinate of each node is only recomputed\n     * when the force is initialized or when this method is called with a new y, and not on every application of the force.\n     */\n    var yGet: ForceNode<D>.() -> Double = { .0 }\n        set(value) {\n            field = value\n            assignNodes(_nodes)\n        }\n\n    /**\n     * Sets the strength accessor to the specified function, re-evaluates the strength accessor for each node.\n     * The strength determines how much to increment the node\u2019s y-velocity: (y - node.y) \u00d7 strength.\n     * For example, a value of 0.1 indicates that the node should move a tenth of the way from its current y-position\n     * to the target y-position with each application. Higher values moves nodes more quickly to the target position,\n     * often at the expense of other forces or constraints. A value outside the range [0,1] is not recommended.\n     *\n     * If strength is not specified, returns the current strength accessor, which defaults to { 0.1 }.\n     *\n     * The strength accessor is invoked for each node in the simulation, being passed the node and its zero-based index.\n     * The resulting number is then stored internally, such that the strength of each node is only recomputed when the\n     * force is initialized or when this method is called with a new strength, and not on every application of the force.\n     */\n    var strengthGet: ForceNode<D>.() -> Percent = { 10.pct }\n        set(value) {\n            field = value\n            assignNodes(_nodes)\n        }\n\n    private var _nodes = listOf<ForceNode<D>>()\n    private var _strengths = listOf<Double>()\n    private var _y = listOf<Double>()\n\n    override fun assignNodes(nodes: List<ForceNode<D>>) {\n        _nodes = nodes\n\n        _y = nodes.map(yGet)\n        _strengths = nodes.map { it.strengthGet().value }\n    }\n\n    override fun applyForceToNodes(intensity: Double) {\n        _nodes.forEachIndexed { index, node ->\n            node.vy += (_y[index] - node.y) * _strengths[index] * intensity\n        }\n    }\n}"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;kBA4EA,0C;;;;;;;;;;;;;;;eCi8BA,I;gCC0QA,yD;uBAAA,gD;2BAyRA,oD;;;yBArOA,+C;gBC9zCA,K;;;;;;;;;;;;;2BCmDA,oD;;;;IC3DoF,gBAArB,qB;IAA6B,KCqExF,SDrEwF,C;IAA7B,OCsEpD,S;EDtEoD,C;;IAEvC,QAAC,cAAO,aAAP,GAAsB,GAAvB,IAA8B,Y;EAA9B,C;;;;;;;;;IEF8B,gBAAjB,iB;IDqEjC,SCrE0D,gB;IAAzB,ODsE1B,S;ECtE0B,C;;IAYjC,gBPgEsC,W;IO9DtC,cAAoB,UAAM,GAAN,EAAU,GAAV,C;EAJH,C;;IAOb,gBAAS,K;EACb,C;;IAGI,WAAW,aAAY,K;IAEvB,aAAS,GAAT,C;IACA,aAAS,GAAT,C;ILghDY,Q;IAAA,OK9gDZ,aL8gDY,W;IAAhB,OAAgB,cAAhB,C;MAAgB,yB;MK7gDR,QL6gDqB,OK7gDV,E;MACX,QL4gDqB,OK5gDV,E;;IAGf,OAAK,OAAK,IAAL,GAAY,WAAO,E;IACxB,OAAK,OAAK,IAAL,GAAY,WAAO,E;ILwgDZ,U;IAAA,SKtgDZ,aLsgDY,W;IAAhB,OAAgB,gBAAhB,C;MAAgB,6B;MAAa,SKrgDrB,KLqgDqB,SKrgDP,EAAL,GAAS,I;MLqgDG,SKpgDrB,KLogDqB,SKpgDP,EAAL,GAAS,I;;EAE1B,C;;;;;;;ICpC6E,gBAApB,oB;IAA0B,IFmEnF,W;IEnEyD,OFoElD,S;EEpEkD,C;;IAUzD,WAAgB,uB;IAChB,WAAgB,uB;IAEhB,YACyB,G;IACzB,aAA0B,G;IAC1B,YAAyB,wCAAO,I;IAChC,YAAyB,wCAAO,I;IAChC,uD;IAEA,4BAKiB,C;IAKjB,0BAQkB,QAAH,EAAG,C;IAKlB,2BAS2C,+B;IAM3C,gBRgBsC,W;IQftC,mBResC,W;EQlElB,C;;;;;MAUpB,iC;IAAA,C;;MAAA,wC;IAAA,C;;;;MAEA,gC;IAAA,C;;MAOQ,4BPg/BwC,MAAW,KOh/BvC,CPg/BuC,EOh/BpC,KPg/BoC,C;IO/+BvD,C;;;;MAEJ,8B;IAAA,C;;MAUQ,0BAAQ,KAAM,kB;IAClB,C;;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C/C,MZ0+C+C,IY1+C1C,GAAL,GAAW,KAAK,C;MZ0+C+B,IYz+C/C,MZy+C+C,IYz+C1C,GAAL,GAAW,KAAK,C;;EAExB,C;;IA5D6C,Y;EAAM,C;;IAkBH,OAAG,QAAH,EAAG,C;EAAI,C;;IASb,4B;MAAE,uC;IAAF,C;EAAA,C;;;;;;;;;IC5B1C,iBAAsB,K;IAYtB,+BAK6C,oC;IAM7C,+BfuCsC,W;IevBtC,gBfuBsC,W;IenBtC,iBfmBsC,W;IedtC,oBXKwD,oB;IWJxD,mBXIwD,oB;IWHxD,iBAAsB,sBAAM,oCAAN,C;IA8BtB,2BAGoB,QAAJ,GAAI,C;IAKpB,8BAKuB,QAAJ,GAAI,C;IAiB+B,gBAAnB,iBAAa,M;IAAM,QAAI,MAAM,K;IAZhE,gCAYqB,YAAQ,Md6QwB,MAAW,KAAI,SAAJ,EAAU,CAAV,Cc7Q3C,C;IAKrB,iCAGwB,QAAF,CAAE,C;IAKxB,mBAAwB,G;EA7HH,C;;IAKoB,W;EAAA,C;;IAA9B,oB;MAAA,OAA6B,6B;IAAM,Q;IAAqB,gBAAZ,Y;IAAkB,IToDzE,W;ISpD8C,4CTqDvC,SSrDuC,8B;EAAA,C;;IACL,W;EAAA,C;;IAA9B,oB;MAAA,OAA6B,6B;IAAM,Q;IAAqB,gBAAZ,Y;IAAkB,ITmDzE,W;ISnD8C,4CToDvC,SSpDuC,8B;EAAA,C;;IACG,W;EAAA,C;;IAAlC,oB;MAAA,OAAiC,iC;IAAM,Q;IAAyB,gBAAhB,gB;IAAsB,ITkDrF,W;ISlDsD,4CTmD/C,SSnD+C,kC;EAAA,C;;IACH,Q;IAA0B,gBAAjB,iB;IAAuB,ITiDnF,W;ISjDmD,4CTkD5C,SSlD4C,mC;EAAA,C;;IACF,W;EAAA,C;;IAAlC,oB;MAAA,OAAiC,iC;IAAM,Q;IAAyB,gBAAhB,gB;IAAsB,ITgDrF,W;IShDsD,4CTiD/C,SSjD+C,kC;EAAA,C;;IACG,Q;IAA6B,gBAApB,oB;IAA0B,IT+C5F,W;IS/CyD,4CTgDlD,SShDkD,sC;EAAA,C;;IACN,Q;IAA0B,gBAAjB,iB;IAAuB,IT8CnF,W;IS9CmD,4CT+C5C,SS/C4C,mC;EAAA,C;;IACJ,W;EAAA,C;;IAAjC,oB;MAAA,OAAg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"}
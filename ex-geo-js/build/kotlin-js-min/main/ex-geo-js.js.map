{"version":3,"file":"ex-geo-js.js","sources":["../../../../ex-geo-common/src/main/kotlin/EarthEventsControl.kt","kotlin/math.kt","../../../../ex-geo-common/src/main/kotlin/EarthAutoRotate.kt","../../../../ex-geo-common/src/main/kotlin/EarthCommon.kt","util/Standard.kt","../../../../ex-geo-common/src/main/kotlin/GeoPathNode.kt","../../../src/main/kotlin/EarthJs.kt","generated/_Collections.kt","org.w3c/org.w3c.dom.kt","generated/_Arrays.kt","../../../../../../../../../../../dummy.kt"],"sourcesContent":["import io.data2viz.examples.geo.geoPathNode\nimport io.data2viz.examples.geo.geoViz\nimport io.data2viz.examples.geo.isProjectionSupportTransformations\nimport io.data2viz.examples.geo.projection\nimport io.data2viz.geo.geometry.*\nimport io.data2viz.geojson.GeoJsonObject\nimport io.data2viz.math.Angle\nimport io.data2viz.math.deg\nimport io.data2viz.math.toRadians\nimport io.data2viz.time.Date\nimport io.data2viz.viz.*\nimport kotlin.math.max\n\n\n@ExperimentalKZoomEvent\nfun geoVizEventsControl(\n    world: GeoJsonObject,\n    projectionName: String,\n    vizWidth: Double = 500.0,\n    vizHeight: Double = 500.0\n): Viz {\n    val viz = geoViz(world, projectionName, vizWidth, vizHeight)\n\n    if (isProjectionSupportTransformations) {\n        viz.addGeoControlEvents()\n        viz.launchStartRotateAnimation()\n        viz.launchEventsControlRedrawAnimation()\n    }\n\n    return viz\n}\n\nvar isNeedRedrawAfterControlEvents = false\n\nlateinit var startDragCartesianPoint: DoubleArray\nlateinit var startDragQuaternion: DoubleArray\nlateinit var startDragRotationAngles: Array<Angle>\nvar isUserStartControlDuringStartAnimation = false\n\n// 0 scale remove all nodes, negative scale invert geo coordinates\nval minProjectionScale = 10.0\nval diffInMillisecondsToDetectZoom = 200\nlateinit var startZoomCartesianPoint: DoubleArray\nlateinit var startZoomQuaternion: DoubleArray\nlateinit var startZoomRotationAngles: Array<Angle>\n\n\n@ExperimentalKZoomEvent\nfun zoomStarted(evt: KZoomEvent) {\n\n    if (!isUserStartControlDuringStartAnimation) {\n        isUserStartControlDuringStartAnimation = true\n    }\n\n    val inverted = projection.invert(evt.currentZoomPos.x, evt.currentZoomPos.y)\n\n    startZoomCartesianPoint = cartesian(doubleArrayOf(inverted[0].toRadians(), inverted[1].toRadians()))\n\n    startZoomRotationAngles = arrayOf(\n        projection.rotateLambda,\n        projection.rotatePhi,\n        projection.rotateGamma\n    )\n    startZoomQuaternion = quaternion(\n        doubleArrayOf(\n            startZoomRotationAngles[0].deg,\n            startZoomRotationAngles[1].deg,\n            startZoomRotationAngles[2].deg\n        )\n\n    )\n}\n\n/**\n * Port of https://github.com/vasturiano/d3-geo-zoom\n */\n@ExperimentalKZoomEvent\nfun zoomed(evt: KZoomEvent) {\n\n    val previousRotateLambda = projection.rotateLambda\n    val previousRotatePhi = projection.rotatePhi\n    val previousRotateGamma = projection.rotateGamma\n    projection.scale = max(projection.scale + evt.delta, minProjectionScale)\n\n    projection.rotate(\n        startZoomRotationAngles[0],\n        startZoomRotationAngles[1],\n        startZoomRotationAngles[2]\n    )\n\n    val inverted = projection.invert(evt.currentZoomPos.x, evt.currentZoomPos.y)\n\n    val currentZoomCartesianPoint =\n        cartesian(doubleArrayOf(inverted[0].toRadians(), inverted[1].toRadians()))\n\n    if (!currentZoomCartesianPoint[0].isNaN() &&\n        !currentZoomCartesianPoint[1].isNaN() &&\n        !currentZoomCartesianPoint[2].isNaN()\n    ) {\n\n        val currentZoomQuaternion = quaternionMultiply(\n            startZoomQuaternion,\n            quaternionDelta(startZoomCartesianPoint, currentZoomCartesianPoint)\n        )\n\n        val rotationAngles = eulerRotation(currentZoomQuaternion)\n        rotationAngles[2] = 0.0; // Don't rotate on Z axis\n        rotateByAngles(rotationAngles[0].deg, rotationAngles[1].deg, rotationAngles[2].deg)\n    } else {\n        projection.rotate(\n            previousRotateLambda,\n            previousRotatePhi,\n            previousRotateGamma\n        )\n    }\n\n}\n\n\nfun Viz.launchEventsControlRedrawAnimation() {\n\n    animation {\n        if(isNeedRedrawAfterControlEvents) {\n            geoPathNode.redrawPath()\n        }\n    }\n}\n\n\nfun Viz.launchStartRotateAnimation() {\n\n    val durationInMs = 3000L\n    val totalLambdaAngleDiffDeg = 360\n    val startRotationLambda = projection.rotateLambda\n\n    val endTime = Date().apply { plusMilliseconds(durationInMs) }\n\n    isUserStartControlDuringStartAnimation = false\n    animation {\n        val diffMilliseconds = endTime.getTime() - Date().getTime()\n\n        if (diffMilliseconds > 0 && !isUserStartControlDuringStartAnimation) {\n\n            val percent = 1 - diffMilliseconds / durationInMs\n\n            val deceleratedPercent = sqrtDecelerate(percent)\n\n            val currentFrameRotationDegree = (deceleratedPercent * totalLambdaAngleDiffDeg).deg\n            projection.rotateLambda = startRotationLambda + currentFrameRotationDegree\n            geoPathNode.redrawPath()\n        } else {\n            stop()\n        }\n    }\n}\n\nfun sqrtDecelerate(originPercent: Double) = (1 - (1 - originPercent) * (1 - originPercent))\n\n/**\n *\n * Adds Drag and Zoom events listeners to Rotate and Scale geo globe\n *\n * Rotate implementation ported from https://observablehq.com/@d3/quaternion-dragging\n */\n@ExperimentalKZoomEvent\nfun Viz.addGeoControlEvents() {\n\n    on(KPointerDrag) { evt ->\n        when (evt.action) {\n\n            KDragEvent.KDragAction.Start -> {\n\n                if (!isUserStartControlDuringStartAnimation) {\n                    isUserStartControlDuringStartAnimation = true\n                }\n\n                val inverted = projection.invert(evt.pos.x, evt.pos.y)\n                startDragCartesianPoint = cartesian(doubleArrayOf(inverted[0].toRadians(), inverted[1].toRadians()))\n                startDragRotationAngles = arrayOf(\n                    projection.rotateLambda,\n                    projection.rotatePhi,\n                    projection.rotateGamma\n                )\n                startDragQuaternion = quaternion(\n                    doubleArrayOf(\n                        startDragRotationAngles[0].deg,\n                        startDragRotationAngles[1].deg,\n                        startDragRotationAngles[2].deg\n                    )\n\n                )\n            }\n            KDragEvent.KDragAction.Dragging -> {\n\n                val previousRotateLambda = projection.rotateLambda\n                val previousRotatePhi = projection.rotatePhi\n                val previousRotateGamma = projection.rotateGamma\n\n                projection.rotate(\n                    startDragRotationAngles[0],\n                    startDragRotationAngles[1],\n                    startDragRotationAngles[2]\n                )\n\n                val inverted = projection.invert(evt.pos.x, evt.pos.y)\n\n                val currentDragCartesianPoint =\n                    cartesian(doubleArrayOf(inverted[0].toRadians(), inverted[1].toRadians()))\n\n\n//                if (!currentDragCartesianPoint[0].isNaN() &&\n//                    !currentDragCartesianPoint[1].isNaN() &&\n//                    !currentDragCartesianPoint[2].isNaN()\n//                ) {\n\n                    val currentDragQuaternion = quaternionMultiply(\n                        startDragQuaternion,\n                        quaternionDelta(startDragCartesianPoint, currentDragCartesianPoint)\n                    )\n\n                    val rotationAngles = eulerRotation(currentDragQuaternion)\n                    rotateByAngles(rotationAngles[0].deg, rotationAngles[1].deg, rotationAngles[2].deg)\n//                } else {\n//                    projection.rotate(\n//                        previousRotateLambda,\n//                        previousRotatePhi,\n//                        previousRotateGamma\n//                    )\n//                }\n\n            }\n\n        }\n    }\n\n    var lastZoomTime = Date()\n\n    on(KZoom) { evt ->\n\n        val inverted = projection.invert(evt.currentZoomPos.x, evt.currentZoomPos.y)\n\n        // dont zoom if pointer not on globe\n        if(inverted[0].isNaN() || inverted[1].isNaN()) {\n            return@on\n        }\n\n        val now = Date()\n        val diffMilliseconds = now.getTime() - lastZoomTime.getTime()\n        if (diffMilliseconds > diffInMillisecondsToDetectZoom) {\n            zoomStarted(evt)\n        } else {\n            zoomed(evt)\n        }\n\n        lastZoomTime = now\n\n    }\n\n}\n\n\nprivate fun rotateByAngles(\n    angleLambda: Angle,\n    anglePhi: Angle,\n    angleGamma: Angle\n) {\n    projection.rotate(angleLambda, anglePhi, angleGamma)\n    isNeedRedrawAfterControlEvents = true\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n@file:Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.Math as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x).unsafeCast<Double>() // TODO: Remove unsafe cast after removing public js.math\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x).unsafeCast<Double>()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x).unsafeCast<Double>()\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.withSign(sign: Double): Double {\n    val thisSignBit = js(\"Kotlin\").doubleSignBit(this).unsafeCast<Int>()\n    val newSignBit = js(\"Kotlin\").doubleSignBit(sign).unsafeCast<Int>()\n    return if (thisSignBit == newSignBit) this else -this\n}\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n",null,null,null,null,null,null,null,null,null],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAmIuB,yB;;;eCmPvB,I;;;;;;;;;;;;;;;;;;ICnWQ,IAAI,kCAAJ,C;MACI,aAAa,iBAAb,C;;IAER,W;EAAA,C;;IATA,wB;MAAA,WAAmB,K;IACnB,yB;MAAA,YAAoB,K;IAEpB,UAAU,OAAO,KAAP,EAAc,cAAd,EAA8B,QAA9B,EAAwC,SAAxC,C;IAEV,GAAI,mBAAU,uBAAV,C;IAKJ,OAAO,G;EACX,C;;IAMI,iBAAiB,WAAY,c;IAE7B,eAAe,WAAO,U;IAEtB,kCAAkC,C;IAElC,aAAa,K;IACb,YAAa,WAAW,MAAZ,GAAsB,M;IAClC,YAAY,QAAQ,GAAR,GAAc,2BAAd,GAA4C,G;IAExD,0BAAgC,QAAN,KAAM,C;IAChC,WAAY,a;EAChB,C;;IC7BQ,kBAAQ,K;IACZ,W;EAAA,C;;;;;;;;IAoCQ,OAAA,iBAAY,c;EAAZ,C;;;;;;IAIZ,kB;EAAA,C;;IAAA,2B;EAAA,C;;IA0BY,cAAI,I;IACJ,cAAI,I;IACJ,iBAAkB,c;IACtB,W;EAAA,C;;IAEK,4B;MACD,cAAI,I;MACJ,cAAI,I;MACJ,iBAAkB,c;MAClB,wBAAc,sB;MAClB,W;IALK,C;EAAA,C;;IAyBK,iC;MAEN,iBAAI,0BAAiB,GAAjB,C;MAEJ,IAAI,iBAAI,MAAJ,IAAa,CAAjB,C;QACI,0BAAkB,mBAA2B,WAAV,iBAAI,MAAM,C;;MAIrD,W;IATU,C;EAAA,C;;IAWD,sC;MAEL,cAAQ,Q;MACR,eAAS,S;MAET,iBAAY,a;MAChB,W;IANS,C;EAAA,C;;IA1DF,4B;MAgCoC,IAAN,I;MA/BrC,kBAAQ,gB;MACR,mBAAS,iB;MAEmB,kBAAd,iB;MAAoB,6C;MAAA,mC;MCOtC,WDNQ,UAAoB,gB;MCM5B,WDLQ,eAAc,G;MCKtB,WDJQ,QAAkB,qB;MCI1B,WDHQ,iBAAgB,oB;MCGxB,WDFQ,WAAU,e;MCElB,WDDQ,a;MANJ,gBCQG,WDRH,C;MAUA,sBAAI,iBAAJ,C;MAEA,UAAU,uBAAK,oBAAL,C;MAMV,uBAAK,8CAAL,C;MAUqC,QAAM,sBAAN,C;aACjC,W;aAAA,U;UAA2B,Y;UAA3B,K;gBACQ,W;UAFyB,K;;MAArC,yC;MASA,IAAI,kCAAJ,C;QACI,iBAAY,cAAc,gBAAW,QAAJ,GAAI,CAAX,EAAoB,QAAJ,GAAI,CAApB,EAA6B,QAAJ,GAAI,CAA7B,C;QAC1B,iBAAY,a;;MAIhB,4BAAU,2BAAV,C;MAWA,2BAAS,iCAAT,C;MASJ,W;IAnEW,C;EAAA,C;;IAPmD,wB;MAAA,WAAmB,K;IAAO,yB;MAAA,YAAoB,K;IAE5G,iBAAiB,uCAAe,cAAf,E;IACjB,wBAAwB,WAAW,G;IACnC,wBAAwB,YAAY,G;IAGpC,OAAO,IAAI,qEAAJ,C;EAoEX,C;;IAKA,mB;IACI,oBAAmB,E;IACnB,aAAY,G;IACZ,aAAY,C;IACZ,iBAAgB,wCAAO,I;EAJ3B,C;;IAYY,Q;IAFJ,IAAI,mBAAa,wCAAO,IAAxB,C;MACI,iBAAY,O;IAChB,IAAI,yDAAW,iBAAf,C;MACI,gBAAgB,UAAU,c;MAC1B,aAAQ,SAAQ,iBAAR,GAAuB,S;MAC/B,iBAAY,O;MACZ,aAAQ,C;;EAEhB,C;;;;;;;;IAlBJ,0B;MAAA,S;;IAAA,mB;EAAA,C;;IHtHI,wB;MAAA,WAAmB,K;IACnB,yB;MAAA,YAAoB,K;IAEpB,UAAU,OAAO,KAAP,EAAc,cAAd,EAA8B,QAA9B,EAAwC,SAAxC,C;IAEV,IAAI,kCAAJ,C;MACQ,oBAAJ,GAAI,C;MACA,2BAAJ,GAAI,C;MACA,mCAAJ,GAAI,C;;IAGR,OAAO,G;EACX,C;;;;;;IAIA,8B;EAAA,C;;IAAA,mD;EAAA,C;;;;;IACA,0B;EAAA,C;;IAAA,2C;EAAA,C;;;;;IACA,8B;EAAA,C;;IAAA,mD;EAAA,C;;;;;;;;IAMA,8B;EAAA,C;;IAAA,mD;EAAA,C;;;;;IACA,0B;EAAA,C;;IAAA,2C;EAAA,C;;;;;IACA,8B;EAAA,C;;IAAA,mD;EAAA,C;;IAMI,IAAI,CAAC,sCAAL,C;MACI,yCAAyC,I;;IAG7C,eAAe,gBAAW,gBAAO,GAAI,eAAe,EAA1B,EAA6B,GAAI,eAAe,EAAhD,C;IAE1B,4BAA0B,UAAU,kBAA0B,UAAZ,SAAS,CAAT,CAAY,CAA1B,EAAmD,UAAZ,SAAS,CAAT,CAAY,CAAnD,EAAV,CAA1B,C;IAEA,4BAA0B,CACtB,gBAAW,aADW,EAEtB,gBAAW,UAFW,EAGtB,gBAAW,YAHW,CAA1B,C;IAKA,wBAAsB,WAClB,kBACI,8BAAwB,CAAxB,CAA2B,IAD/B,EAEI,8BAAwB,CAAxB,CAA2B,IAF/B,EAGI,8BAAwB,CAAxB,CAA2B,IAH/B,EADkB,CAAtB,C;EAQJ,C;;IAQI,2BAA2B,gBAAW,a;IACtC,wBAAwB,gBAAW,U;IACnC,0BAA0B,gBAAW,Y;IACrC,2B;IAAmB,QAAI,gBAAW,MAAX,GAAmB,GAAI,M;IAA3B,QAAkC,kB;IAArD,aC2SyD,MAAW,KAAI,CAAJ,EAAO,CAAP,C;IDzSpE,gBAAW,gBACP,8BAAwB,CAAxB,CADO,EAEP,8BAAwB,CAAxB,CAFO,EAGP,8BAAwB,CAAxB,CAHO,C;IAMX,eAAe,gBAAW,gBAAO,GAAI,eAAe,EAA1B,EAA6B,GAAI,eAAe,EAAhD,C;IAE1B,gCACI,UAAU,kBAA0B,UAAZ,SAAS,CAAT,CAAY,CAA1B,EAAmD,UAAZ,SAAS,CAAT,CAAY,CAAnD,EAAV,C;IAEJ,IAAI,CAA8B,QAA7B,0BAA0B,CAA1B,CAA6B,CAA9B,IACA,CAA8B,QAA7B,0BAA0B,CAA1B,CAA6B,CAD9B,IAEA,CAA8B,QAA7B,0BAA0B,CAA1B,CAA6B,CAFlC,C;MAKI,4BAA4B,mBACxB,yBADwB,EAExB,gBAAgB,6BAAhB,EAAyC,yBAAzC,CAFwB,C;MAK5B,qBAAqB,cAAc,qBAAd,C;MACrB,eAAe,CAAf,IAAoB,G;MACpB,eAAiC,QAAlB,eAAe,CAAf,CAAkB,CAAjC,EAAwD,QAAlB,eAAe,CAAf,CAAkB,CAAxD,EAA+E,QAAlB,eAAe,CAAf,CAAkB,CAA/E,C;;;MAEA,gBAAW,gBACP,oBADO,EAEP,iBAFO,EAGP,mBAHO,C;;EAOnB,C;;IAMQ,IAAG,8BAAH,C;MACI,iBAAY,a;;IAEpB,W;EAAA,C;;IAJA,4BAAU,yCAAV,C;EAKJ,C;;IAYc,gC;MACN,uBAAuB,eAAQ,UAAR,GAAoB,WAAO,U;MAElD,IAAI,mBAAmB,CAAnB,IAAwB,CAAC,sCAA7B,C;QAEI,cAAc,IAAI,mBAAmB,oBAAnB,W;QAElB,yBAAyB,eAAe,OAAf,C;QAEzB,iCAAgF,QAA9C,qBAAqB,+BAAyB,C;QAChF,gCAA0B,yCAAsB,0BAAtB,C;QAC1B,iBAAY,a;;;QAEZ,gB;;MAER,W;IAfU,C;EAAA,C;;IAPV,wB;IACA,8BAA8B,G;IAC9B,0BAA0B,gBAAW,a;IAEhB,kBAAP,W;II7Dd,WJ6D6B,uC;IAA7B,cI5DO,W;IJ8DP,yCAAyC,K;IACzC,4BAAU,sGAAV,C;EAgBJ,C;;IAE4C,OAAC,IAAI,CAAC,IAAI,aAAL,KAAuB,IAAI,aAA3B,C;EAAL,C;;IAYpC,QAAM,GAAI,OAAV,M;WAEI,O;QAEI,IAAI,CAAC,sCAAL,C;UACI,yCAAyC,I;;;QAG7C,eAAe,gBAAW,gBAAO,GAAI,IAAI,EAAf,EAAkB,GAAI,IAAI,EAA1B,C;QAC1B,4BAA0B,UAAU,kBAA0B,UAAZ,SAAS,CAAT,CAAY,CAA1B,EAAmD,UAAZ,SAAS,CAAT,CAAY,CAAnD,EAAV,CAA1B,C;QACA,4BAA0B,CACtB,gBAAW,aADW,EAEtB,gBAAW,UAFW,EAGtB,gBAAW,YAHW,CAA1B,C;QAKA,wBAAsB,WAClB,kBACI,8BAAwB,CAAxB,CAA2B,IAD/B,EAEI,8BAAwB,CAAxB,CAA2B,IAF/B,EAGI,8BAAwB,CAAxB,CAA2B,IAH/B,EADkB,CAAtB,C;QAbJ,K;WAsBA,U;QAEI,2BAA2B,gBAAW,a;QACtC,wBAAwB,gBAAW,U;QACnC,0BAA0B,gBAAW,Y;QAErC,gBAAW,gBACP,8BAAwB,CAAxB,CADO,EAEP,8BAAwB,CAAxB,CAFO,EAGP,8BAAwB,CAAxB,CAHO,C;QAMX,iBAAe,gBAAW,gBAAO,GAAI,IAAI,EAAf,EAAkB,GAAI,IAAI,EAA1B,C;QAE1B,gCACI,UAAU,kBAA0B,UAAZ,WAAS,CAAT,CAAY,CAA1B,EAAmD,UAAZ,WAAS,CAAT,CAAY,CAAnD,EAAV,C;QAQA,4BAA4B,mBACxB,yBADwB,EAExB,gBAAgB,6BAAhB,EAAyC,yBAAzC,CAFwB,C;QAK5B,qBAAqB,cAAc,qBAAd,C;QACrB,eAAiC,QAAlB,eAAe,CAAf,CAAkB,CAAjC,EAAwD,QAAlB,eAAe,CAAf,CAAkB,CAAxD,EAA+E,QAAlB,eAAe,CAAf,CAAkB,CAA/E,C;QA7BR,K;;IAyCR,W;EAAA,C;;IAIU,sB;MAEN,eAAe,gBAAW,gBAAO,GAAI,eAAe,EAA1B,EAA6B,GAAI,eAAe,EAAhD,C;MAG1B,IAAe,QAAZ,SAAS,CAAT,CAAY,CAAZ,IAAmC,QAAZ,SAAS,CAAT,CAAY,CAAtC,C;QACI,M;;MAGJ,UAAU,W;MACV,uBAAuB,GAAI,UAAJ,GAAgB,sBAAa,U;MACpD,IAAI,mBAAmB,8BAAvB,C;QACI,YAAY,GAAZ,C;;;QAEA,OAAO,GAAP,C;;MAGJ,yBAAe,G;MAEnB,W;IAnBU,C;EAAA,C;;IAtEV,qBAAG,qCAAH,EAAiB,0BAAjB,C;IAoEA,uBAAmB,WAAnB,C;IAEA,qBAAG,uBAAH,EAAU,0CAAV,C;EAqBJ,C;;IAQI,gBAAW,gBAAO,WAAP,EAAoB,QAApB,EAA8B,UAA9B,C;IACX,iCAAiC,I;EACrC,C;;IKnQI,uB;MAAA,UAA8B,I;IAC9B,6B;MAAA,gBAAgC,oB;IAChC,oB;MAAA,OAAiB,c;IAClB,oBAAS,IAAT,C;IAHC,sB;IACA,kC;EAFkB,C;;IAQd,gBAAc,QAAQ,kBAAR,EAAuB,SAAvB,C;IACd,gB;IACA,SAAQ,iBAAQ,2BAAR,C;EACZ,C;;;;;;;;;;;;;;;;;ICaJ,iB;EAAA,C;;IAAA,yB;EAAA,C;;;;;IACA,uB;EAAA,C;;IAAA,qC;EAAA,C;;;;IAKY,wB;EAAA,C;;;IAcoD,4B;MACpD,uBAAa,OAAb,EAAsB,gBAAtB,C;MACA,sBAAY,gB;MAChB,W;IAHwD,C;EAAA,C;;IAOM,4B;MAC1D,uBAAa,OAAb,EAAsB,sBAAtB,C;MACA,sBAAY,sB;MAChB,W;IAH8D,C;EAAA,C;;IAU1C,oB;IAAqB,W;EAAA,C;;IACf,oB;IAAqB,W;EAAA,C;;IAG/C,IAAI,gBAAJ,C;MACI,+D;;;MAEA,gE;;IAGJ,mBAAmB,CAAC,gB;IANpB,OAOA,E;EACJ,C;;IApCA,eAAa,QAAS,gBAAe,uBAAf,CAAtB,C;IACA,qBAAmB,QAAS,gBAAe,6BAAf,CAA5B,C;IACA,kBAAkB,QAAS,gBAAe,4BAAf,C;IAE3B,oBAAoB,QAAS,gBAAe,mBAAf,CAAT,Q;IC4/CJ,Q;IAAA,OD1/ChB,QC0/CgB,W;IAAhB,OAAgB,cAAhB,C;MAAgB,yB;MDz/CZ,gBAAW,QAAQ,KAAa,cAAT,QAAS,EAAc,QAAd,EAAwB,mBCy/C/B,ODz/C+B,CAAxB,CAAb,C;;ICy/CP,U;IAAA,SDn/ChB,mBCm/CgB,W;IAAhB,OAAgB,gBAAhB,C;MAAgB,6B;MDl/CZ,sBAAiB,QAAQ,KAAa,cAAT,QAAS,EAAc,QAAd,EAAwB,qBCk/CrC,SDl/CqC,CAAxB,CAAb,C;;IAM7B,iCAA2B,gB;IAC3B,uCAAiC,sB;IAGjC,4BAAsB,W;IACtB,kCAA4B,a;IAC5B,qDAA2B,aAA3B,Q;IAYA,oB;EAEJ,C;;IAKI,iBAAiB,QAAS,gBAAe,uBAAf,C;IAE1B,uBAAuB,QAAS,gBAAe,6BAAf,C;IAEhC,oBAAkB,UAAlB,EAA8B,gBAA9B,C;EACJ,C;;IAUoB,Q;IAFhB,sBAAsB,cAAA,cAAA,gBAAiB,QEknGgD,CFlnGxC,gBAAiB,cEknGuB,CFlnGjE,CAA2D,cAAa,OAAb,CAA3D,C;IAEN,IAAI,uBAAwB,mBAAY,eAAZ,CAA5B,C;MACZ,uDAAwB,eAAxB,E;;;MAEA,qBAAA,cAAA,UAAW,QE6mGwE,CF7mGhE,UAAW,cE6mGqD,CF7mGnF,CAA+C,cAAa,OAAb,CAA/C,C;;IAHJ,oB;IAMA,qBAAqB,SAArB,EAAgC,eAAhC,C;IAGJ,iBAAI,CAAc,SAAd,EAAyB,eAAzB,C;EACJ,C;;IAiByD,4B;MAC7C,eAAU,uB;MACoB,kBAA9B,iBAAU,oB;MG82UF,Q;MAAhB,wBAAgB,WAAhB,gB;QAAgB,cAAA,WAAhB,M;QH52UiB,uBG42UY,OH52UZ,EAA4B,cAAU,+BG42U1B,OH52U0B,CAAV,CAA5B,C;;MAEb,W;IANiD,C;EAAA,C;;IAZjC,wC;IAAA,6B;IAAA,yB;IAAA,gD;IAAA,4D;IAAA,wB;EA8BpB,C;;;;;;;;;;;;;YA3BQ,IAAI,oCAAY,WAAZ,CAAJ,C;cACmB,kBAAf,cAAe,Y;cADnB,gB;;;;cAGK,gB;8BAAA,QADA,MAAO,OAAM,YAAQ,2BAAR,CAAN,CACP,O;kBAAA,kBI7HjB,mB;uBJ6HiB,mB;cAAA,Q;;;;;;YACA,gB;4BAAA,QADA,aAAQ,OACR,O;gBAAA,kBI9HjB,mB;qBJ8HiB,mB;YAAA,Q;;YAAQ,kCAAR,aAAQ,C;YAJb,gB;;;YADJ,6B;YAOA,gBAAgB,QAAS,gBAAe,uBAAf,C;YACzB,aAAa,wBAAY,c;YACzB,qBAAS,aAAY,SAAZ,C;YACT,gBAAyB,cAAT,QAAS,EAAc,QAAd,EAAwB,6CAAxB,C;YAOzB,MAAO,aAAY,SAAZ,C;YAEP,+D;YACA,aAAa,QAAQ,OAAR,EAAiB,iCAAjB,C;YAEA,eAAb,yBAAa,EAAe,SAAf,C;YACb,WAAW,gB;YAEX,IAAI,CAAC,IAAL,C;cAzBA,OA0BI,UA1BJ,aA0BI,UA1BJ,8B;;;cAyBA,gB;;;;;YAGJ,W;;;;;;;;;;;;;;;;EAAA,C;;IA9BoB,yD;qBAAA,0H;UAAA,S;eAAA,Q;;eAAA,uB;IAAA,C;EAAA,C;;IAAR,QAAZ,sBAAY,kBAAQ,qDAAR,C;EA+BhB,C;;IAG2E,IAAI,wBAAJ,C;MAAA,OACvE,iBAAiB,OAAjB,EAA0B,cAA1B,EAA0C,QAA1C,EAAoD,SAApD,C;;;MADuE,OAGvE,oBAAoB,OAApB,EAA6B,cAA7B,EAA6C,QAA7C,EAAuD,SAAvD,C;;EAHuE,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IHtG3E,C;;;;;;;;;;;;;;;;;IHpBA,C;;;;;;;;;;;;;;;;;;;;IAKA,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IMlBA,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAeA,C;;;;;;;;IAEA,C;;;;;;;;;;;IAIA,C;;;mBH9BqB,WACjB,aAAY,kBAAZ,CADiB,EAEjB,gBAAe,oBAAoB,qBAApB,CAAf,CAFiB,EAKjB,yBAAwB,8BAAxB,CALiB,EAMjB,2BAA0B,sBAA1B,CANiB,EAOjB,qBAAoB,0BAApB,CAPiB,EAQjB,iBAAgB,0BAAhB,CARiB,EASjB,uBAAsB,4BAAtB,CATiB,EAUjB,iBAAgB,sBAAhB,CAViB,EAWjB,sBAAqB,2BAArB,CAXiB,EAYjB,eAAc,oBAAd,CAZiB,EAajB,eAAc,oBAAd,CAbiB,EAcjB,eAAc,oBAAd,CAdiB,EAejB,mBAAkB,wBAAlB,CAfiB,EAgBjB,mBAAkB,wBAAlB,CAhBiB,EAiBjB,oBAAmB,yBAAnB,CAjBiB,EAkBjB,yBAAwB,8BAAxB,CAlBiB,E;wBAoByB,OAApB,cAAe,KAAK,C;aAE/B,QACX,WADW,EAEX,oBAFW,EAGX,2BAHW,EAIX,2BAJW,EAKX,2BALW,E;4BAQe,WAC1B,gBAAe,gBAAf,CAD0B,E;qBAKP,QAAS,eAAQ,2BAAR,C;2BACH,mBAAoB,eAAQ,cAAR,C;uCAMC,I;mCHpBb,K;2CAKQ,K;uBAGpB,I;mCACY,G;eMpBd,I;4BAEO,K;4BACA,a;kCACM,mB;iCACD,mB;aAEpB,K;cACC,K;oBAK0B,I;sBAET,K;qBAIV,I;;;;;"}